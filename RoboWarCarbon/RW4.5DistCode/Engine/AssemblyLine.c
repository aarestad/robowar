/* RoboTalk Language Compiler *//* 	Written 11/3/89 David Harris	(c) 1989 David Harris	Ported To Macintosh 12/15/89	Reported (ported Again) as a file as part of RoboWar 12/16/89		This program translates RoboTalk source code into	object code designed for easy interpreting. 	The compiler works in three passes, two of which actually	read from the source code.  The first scans for labels and	builds a library of label locations.  The second pass 	again scans through the source and generates code, using	temporary codes for the label jump locations.  The third 	pass seeks out these temporary codes and replaces them with	the actual location of the labels.		There's a bit of sloppiness and breaking of abstraction	barriers here that I haven't fixed.  Numbers from -20000 to	20000 represent numbers.  Codes from 20300 to 20399 are variables;	from 20400 to 20499 are quoted (indirect) variables.  Codes from	20000 to 20099 are aritmetic operations; from 20100 to 20199 are other 	operators.  Codes from 30000 to 30400 are labels.*//* Includes */#include <Carbon/Carbon.h>#include "robotypes.h"#include "Tokens.h"// --- For WASTE//#include "myWASTE.h"/* Globals */short		*prog;				/* Compiled Program Storage */library		lib[libSize];		/* Library of labels */char		token[tokSize];		/* Current token */short		progPtr;			/* Pointer to top of program array */short		libPtr;				/* Pointer to top of library array */short		curLibPtr;			/* Pointer to adjusted library element */short		tokPtr;				/* Pointer to token char */short		lineNum;			/* Current line number of source file */short		bugFlag;			/* Buggy arena instruction located? */short		errFlag;			/* Has error occurred? */short		warningFlag;		/* Is there a warning? */short		unregisteredFlag;	/* Unregistered program too long */long		errStart;			/* Where error began */long		errEnd;				/* Where error ended */short		stoWarnings;		/* 1 means warn on STORE without quoted variable */long		selStartPtr;		/* first instruction highlighted */long		selEndPtr;			/* last instruction highlighted */long		bufPtr;				/* Current position in buffer */Str255		errMsg;				/* Error message */short 		nonCountingIntrQty;		// non-counting-instructions (icon/snd)/* External variables */extern CursHandle		watchCurs;extern WEReference		myWText;extern MenuHandle 		labelMenu;//---r extern TEHandle			myText;extern asmInfo			info;extern short			numBots;extern robot			rob[maxBots];extern short			botSelected;extern char				registered[80];		/* Null = not registered */extern Str255			noName;//extern short			complainLength;		#if __POWERPC__	extern	QDGlobals	qd;					/* To make PowerPC happy */#endif/* Prototypes */pascal Boolean compilerMessageFilter(DialogPtr,EventRecord*,short*);void compilerMessage(void);void updateRobotInArena(void);void assembleRobot(short errorInstruction);void show_bug(short);void show_err(char *msg,short len);void show_warning(char *msg,short len);void comment_err(short line,short where);void do_labeldef(long textPos);void preprocess(void);void correctlabels(void);short isdelim(char c);short isnewdelim(char c);short tokeq(char *ct);short isnumber(void);short isvar(void);void codevar(short name);short islabel(void);void set_label(void);void parse_token(short errorInstruction);void do_comment(void);void compile(short errorInstruction);void write_object(void);/* in Util.c */extern void checkMemErr(char *proc);extern void checkResErr(char *proc);extern void reportMessage(char *message1,char *message2);extern Ptr fileToBuffer(Str255,short vRefNum,long *length);extern Boolean sameBot(short);extern void setVolume(short vRefNum);extern void restoreVolume(void);/* in DraftingBoard.c */extern void showSelected(void);// --- in SyntaxColoring.cextern void SyntaxColorRange(long start, long end, WEReference wasteText);// --- in LabelsExtra.c //extern void AddLabelsToMenu( library theLabels[], short labelsQty, MenuHandle menu, //	short intoMenuAtPos );//extern void DelAllMenuItems(MenuHandle menu);// --- in TextUtil.c long 	FindWordStart(long curPos, Handle text);/* Functions */pascal Boolean compilerMessageFilter(DialogPtr theDialog,EventRecord *theEvent,short *itemHit){#pragma unused (theDialog)	char c;		if (theEvent->what == keyDown) {		c = theEvent->what & charCodeMask;		if (c == 13 || c == 3) {			*itemHit = 1;			return 1;		}	}	return 0;}void compilerMessage(void){	short itemHit;	DialogPtr myDialog;	ModalFilterUPP filterUPP;		CtoPstr((char*)errMsg);	if (errFlag)		ParamText ("\pBug Alert!  Bug Alert!  Bug Alert!",errMsg,noName,noName);	else if (unregisteredFlag)		ParamText ("\pPlease register RoboWar if you",				   "\pwish to compile a program this long.",noName,noName);	else ParamText ("\pWarning:",errMsg,noName,noName);	myDialog = GetNewDialog(CompilerDlogID,NULL,(WindowPtr)-1L);	SysBeep(1);	filterUPP =  NewModalFilterProc(&compilerMessageFilter);	do {		ModalDialog(filterUPP,&itemHit);	} while (!itemHit);	DisposeDialog(myDialog);	WESetSelection(errStart, errEnd, myWText);    //TESetSelect(errStart,errEnd,myText);    showSelected();	DisposeRoutineDescriptor(filterUPP);}void updateRobotInArena(void){	short i,k;		for (i=0; i < numBots; i++)	{		if (sameBot(i)) {			rob[i].progSize = progPtr;			DisposePtr((Ptr)rob[i].prog);			rob[i].prog = (short*)NewPtr(progPtr*2L);			checkMemErr("AssemblyLine:updateRobotInArena");					for (k=0; k<progPtr; k++)				rob[i].prog[k] = prog[k];		}	}}// Starts the compilation processvoid assembleRobot(short errorInstruction){	Rect r;	char 	msg[80];	Str255	tmpMsg;	long	selStart, selEnd;		//MoveHHi((*myText)->hText);	//HLock((*myText)->hText);	info.length = WEGetTextLength( myWText );	//---r //(*myText)->teLength;		SyntaxColorRange( 0, info.length, myWText ); //---n 15/4/98	//	buffer = WEGetText( myWText );		//---r //*(*myText)->hText;		// Set the program Pntr to the maximum size the robot will need	prog = (short*)NewPtr((progMaxSize + maxNonCountingIntr)*2);	if (MemError()) {		reportMessage("Sorry, memory error.","");		prog = NULL;	}	else {		SetCursor (*watchCurs);	    libPtr = 0;	    tokPtr = 0;	    bufPtr = 0;	    bugFlag = 0;	    errFlag = 0;	    warningFlag = 0;	    unregisteredFlag = 0;	    stoWarnings = 1;	    lineNum = 1;	    preprocess();	    bufPtr = 0;	    progPtr = 0;	    tokPtr = 0;	    lineNum = 1;	    curLibPtr = 0;	    selStartPtr = 0;	    selEndPtr = 0;	    compile(errorInstruction);	    //sprintf(msg,"%d snd/icons.",nonCountingIntrQty);	    //reportMessage( msg, "" );	    	    correctlabels();	    	    if (errorInstruction != -1 && bugFlag == 0) 	    	show_bug(1);		    if (progPtr > (nonCountingIntrQty+progMaxSize-1)) {	    	strcpy( (char*)errMsg, "Compiled software too long." );	    	//-sprintf ((char*)errMsg,"Compiled software too long.");	    	errFlag = 1;	    }	  	else if ( nonCountingIntrQty >= 1000 ) {	    	strcpy( (char*)errMsg, "Too many icon and snd instructions." );	    	//-sprintf ((char*)errMsg,"Compiled software too long.");	    	errFlag = 1;	    }	    /*	    else if (progPtr > 99 && !registered[0]) {	    	unregisteredFlag = 1;	    } */	    else if (!errFlag && !bugFlag) {	      	write_object();	      	updateRobotInArena();	 		info.codeLength = progPtr;	 		WEGetSelection( &selStart, &selEnd, myWText );	 		if (selEndPtr-selStartPtr > 0 && selStart != selEnd) {	 			NumToString( selEndPtr-selStartPtr, tmpMsg );	 			strncpy( msg, (char*)(tmpMsg + 1), tmpMsg[0] );	 			msg[ tmpMsg[0] ] = '\0';	 			strcat( msg, " instructions highlighted."); //26 = num of char's	 			//sprintf( msg,  );	 			//sprintf(msg,"%d instructions highlighted.",selEndPtr-selStartPtr);	 			reportMessage(msg,"");	 		}	   	}	    	    SetCursor (&qd.arrow);	    if (errFlag || warningFlag || unregisteredFlag) 	    	compilerMessage();	}	if ( WEGetText(myWText) != NULL) {		//---r   (*myText)->hText != NULL		//HUnlock((*myText)->hText); //---x		checkMemErr("AssemblyLine:assembleRobot");	}	if (prog != NULL) DisposePtr((Ptr)prog);	if (MemError()) reportMessage ("Memory Error #3","Can't dispose of program");	r.top = 55; r.left = 420; r.right = 490; r.bottom = 67;	InvalRect(&r);	r.top = 155; r.left = 370; r.right = 490; r.bottom = 167;	InvalRect(&r);	//complainLength = 0;}void show_bug(short len){	if (!bugFlag) { /* highlight bug that caused crash in Arena */		bugFlag = 1;		if (len == 1 && isdelim(token[0]) || bufPtr == info.length) {			errStart = bufPtr-len;			errEnd = bufPtr;		}		else {			errStart = bufPtr-len-1;			errEnd = bufPtr-1;		}		WESetSelection(errStart, errEnd, myWText );		//---r   	TESetSelect(errStart,errEnd,myText);   		showSelected();	}}void show_err(char *msg,short len){	if (!errFlag && !bugFlag) {		strcpy((char*)errMsg,msg);		errStart = bufPtr-len-1;		errEnd = bufPtr-1;		errFlag = 1;	}}void show_warning(char *msg,short len){	if (!warningFlag && !errFlag && !bugFlag) {		strcpy((char*)errMsg,msg);		errStart = bufPtr-len-1;		errEnd = bufPtr-1;		warningFlag = 1;	}}void comment_err(short line,short where){#pragma unused (line)	strcpy( (char*)errMsg, "No closing } found." );	//-sprintf ((char*)errMsg,"No closing } found.");	errFlag = 1;	errStart = where;	errEnd = where;}	void do_labeldef(long textPos){	short i,err;		tokPtr--;	if (tokPtr > 19) tokPtr = 19;	token[tokPtr] = '\0';	for (i=0; i<tokPtr; i++)		token[i] = toupper(token[i]);	if (libPtr == libSize) show_err("Too many labels",tokPtr+1);	else {		err = 0;		for (i=0; i<libPtr; i++)			if (!strcmp(lib[i].name,token)) err = 1;				lib[libPtr].textPos = FindWordStart( textPos-3, WEGetText( myWText ) );	// - set the label to the current text pos;	}	if (err) show_err("Duplicate label",tokPtr+1);	else { 		for (i=0; i<=tokPtr; i++)			lib[libPtr].name[i] = token[i];		lib[libPtr].code = libPtr+labelBaseCode; /* Set preliminary label line */		libPtr++; 	} }void preprocess(void){	char c;		/* Character read from file */		while (bufPtr < info.length && !errFlag && !bugFlag) {		c = WEGetChar(bufPtr++, myWText);    	if (c == '{' || c == '#') {    		token[0] = c;    		token[1] = 0;    		do_comment();    		tokPtr = 0;    	}		else if (isdelim(c) || bufPtr==info.length) {			if (c == ':') token[tokPtr++] = ':';			token[tokPtr] = '\0';    		if (tokPtr > 0 && token[tokPtr-1] == ':') do_labeldef(bufPtr);    		tokPtr = 0;    		if (c == '\r') lineNum++;    	}    	else token[tokPtr++] = c;    }}void correctlabels(void){	short i;	for (i=0; i<= progPtr; i++)		if (prog[i] >= labelBaseCode && prog[i] < labelBaseCode+libSize)			prog[i] = lib[prog[i]-labelBaseCode].real;}short isdelim(char c){    short result = 0;    if (isspace(c) || c == ';' || c == ',' || c == -1 || isnewdelim(c))    	result = 1;     return result;}short isnewdelim(char c){	/* These delimiters mean that the previous token should be processed,	   then a single token c should also be processed */	   	short result = 0;	if (c == '*' || /* Note + and - are not treated this way */		c == '/' || /* Because they are needed in expressions such as */		c == '>' || /* -1 or (+3) */		c == '<' ||		c == '=' ||		c == '!' ||		c == '{' ||		c == '#')		result = 1;	return result;}short tokeq(char *ct){	return (strcmp(token,ct) == 0);}short isnumber(void){	short i,result = 1;		for (i=0; i<tokPtr; i++)		if ((isdigit(token[i]) ||  /* Digit or 1st character is + or - */			((token[i] == '-' || token[i] == '+') && i == 0))			== 0) result = 0;	return result;}short isvar(void){	short result = 0,length,indirect;		length = tokPtr;	if (token[length-1] == '\'') {		indirect = 1;	 	length--;	 	token[length] = 0;	}	else indirect = 0;		if (length == 1) {		if (isupper(token[0])) result = 20300+(token[0]-'A'); 	}	else if (tokeq("FIRE")) result = fire_;	/* Return codes for variable */	else if (tokeq("ENERGY")) result = energy_;	else if (tokeq("SHIELD")) result = shield_;	else if (tokeq("RANGE")) result = range_;	else if (tokeq("AIM")) result = aim_;	else if (tokeq("SPEEDX")) result = speedx_;	else if (tokeq("SPEEDY")) result = speedy_;	else if (tokeq("DAMAGE")) result = damage_;	else if (tokeq("RANDOM")) result = random_;	else if (tokeq("MISSILE")) result = missile_;	else if (tokeq("NUKE")) result = nuke_;	else if (tokeq("COLLISION")) result = collision_;	else if (tokeq("CHANNEL")) result = channel_;	else if (tokeq("SIGNAL")) result = signal_;	else if (tokeq("MOVEX")) result = movex_;	else if (tokeq("MOVEY")) result = movey_;	else if (tokeq("JOCE")) result = joce_;	else if (tokeq("RADAR")) result = radar_;	else if (tokeq("LOOK")) result = look_;	else if (tokeq("SCAN")) result = scan_;	else if (tokeq("CHRONON")) result = chronon_;	else if (tokeq("HELL") || tokeq("HELLBORE")) result = hell_;	else if (tokeq("DRONE")) result = drone_; // ---	else if (tokeq("MINE")) result = mine_;	else if (tokeq("LASER")) result = laser_; // ---	else if (tokeq("SUSIE")) result = susie_;	else if (tokeq("ROBOTS")) result = robots_;	else if (tokeq("FRIEND")) result = friend_;	else if (tokeq("BULLET")) result = bullet_;	else if (tokeq("DOPPLER")) result = doppler_;	else if (tokeq("DEBUGGER") || tokeq("DEBUG")) result = debug_;	else if (tokeq("STUNNER")) result = stunner_;	else if (tokeq("TOP")) result = top_;	else if (tokeq("BOT") || tokeq ("BOTTOM")) result = bottom_;	else if (tokeq("LEFT")) result = left_;	else if (tokeq("RIGHT")) result = right_;	else if (tokeq("WALL")) result = wall_;	else if (tokeq("TEAMMATES")) result = teammates_;	else if (tokeq("PROBE")) result = probe_;	else if (tokeq("HISTORY")) result = history_;	else if (tokeq("ID")) result = id_;	else if (tokeq("KILLS")) result = kills_;	if (result && result < 20000) result += 20300;	if (indirect && result) result += 100;	return result;}void codevar(short name){	short indirect;		if (name >= 20400) {		name -= 100;		indirect = 1;	}	else indirect = 0;    prog[progPtr++] = name;    if (!indirect)     	prog[progPtr++] = recall_;}	//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// returns the absolute position of a the current token's decoration, // assuming the current token is a label.short islabel(void){	short i,result = 0;    if (tokPtr > 19) token[19] = 0;	for (i=0; i<libPtr && result == 0; i++) {		if (tokeq(lib[i].name)) result = lib[i].code;	}	return result;}//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=void do_comment(void){	char c;	short depth = 1, i;	char directive[80];	short startLine,startPlace;			if (token[0] == '{') {					/* {} delimited comment */		startLine = lineNum;		startPlace = bufPtr;		do {			c = WEGetChar(bufPtr++, myWText);			if (c == '{') depth++;			if (c == '}') depth--;    		if (c == '\r') lineNum++;		} while (depth != 0 && bufPtr < info.length);			if (depth) comment_err(startLine,startPlace);	}	else if ( WEGetChar(bufPtr, myWText) == '!' && WEGetChar(bufPtr+1, myWText) == '!') {		/* Assembler directive delimited by #!! */		bufPtr += 2; i = 0;		while (bufPtr < info.length && (c= WEGetChar(bufPtr++, myWText) ) != '\r') {			if (!isspace(c)) {				directive[i++] = tolower(c);				if (i > 78) i = 78; /* prevent buffer overflow */			}		}		if (c == '\r') lineNum++;		directive[i] = 0;		if (strcmp(directive, "nostowarnings") == 0) stoWarnings = 0;		else if (strcmp(directive, "stowarnings") == 0) stoWarnings = 1;		else show_err("Bad assembler directive", tokPtr+1);	}	else do {								/* # and eol delimited comment */		c = WEGetChar(bufPtr++, myWText);		if (c == '\r') lineNum++;	} while (c != '\r' && bufPtr < info.length);}void set_label(void){	lib[curLibPtr++].real = progPtr;}void parse_token(short errorInstruction){    short i,val;    short tokType = unknown_;    long  selStart, selEnd;    if (tokPtr == 0) tokType = null_;    else if (token[0] == '{' || token[0] == '#') do_comment();    else if (token[tokPtr-1] == ':') set_label();    else {    	for (i=0; i<tokPtr; i++) token[i] = toupper(token[i]);		if      (tokeq("+")) tokType = plus_;    	else if (tokeq("-")) tokType = minus_;    	else if (tokeq("*")) tokType = times_;    	else if (tokeq("/")) tokType = divide_;        	else if (tokeq("<")) tokType = less_;    	else if (tokeq(">")) tokType = greater_;    	else if (tokeq("=")) tokType = equal_;    	else if (tokeq("!")) tokType = notequal_;    	else if (tokeq("STO") || tokeq("STORE")) {    		tokType = store_;    		if (stoWarnings && (prog[progPtr-1] < 20300 || prog[progPtr-1] > 20399))     			show_warning("Store with unquoted variable",tokPtr);    	}    	else if (tokeq("DROP")) tokType = drop_;    	else if (tokeq("SWAP")) tokType = swap_;    	else if (tokeq("ROLL")) tokType = roll_;    	else if (tokeq("JUMP") || tokeq("RETURN")) tokType = jump_;    	else if (tokeq("CALL")) tokType = call_;    	else if (tokeq("DUP") || tokeq("DUPLICATE")) tokType = dup_;    	else if (tokeq("IF")) tokType = if_;    	else if (tokeq("IFE")) tokType = ife_;    	else if (tokeq("NOP")) tokType = nop_;    	else if (tokeq("OR")) tokType = or_;    	else if (tokeq("AND")) tokType = and_;    	else if (tokeq("EOR") || tokeq("XOR")) tokType = eor_;    	else if (tokeq("MOD")) tokType = mod_;    	else if (tokeq("BEEP")) tokType = beep_;    	else if (tokeq("CHS")) tokType = chs_;    	else if (tokeq("NOT")) tokType = not_;    	else if (tokeq("ARCTAN")) tokType = arctan_;    	else if (tokeq("ABS")) tokType = abs_;    	else if (tokeq("SIN") || tokeq("SINE")) tokType = sin_;    	else if (tokeq("COS") || tokeq("COSINE")) tokType = cos_;    	else if (tokeq("TAN") || tokeq("TANGENT")) tokType = tan_;    	else if (tokeq("SQRT")) tokType = sqrt_;    	else if (tokeq("ICON0")) { tokType = icon0_; nonCountingIntrQty++; }    	else if (tokeq("ICON1")) { tokType = icon1_; nonCountingIntrQty++; }    	else if (tokeq("ICON2")) { tokType = icon2_; nonCountingIntrQty++; }    	else if (tokeq("ICON3")) { tokType = icon3_; nonCountingIntrQty++; }    	else if (tokeq("ICON4")) { tokType = icon4_; nonCountingIntrQty++; }    	else if (tokeq("ICON5")) { tokType = icon5_; nonCountingIntrQty++; }    	else if (tokeq("ICON6")) { tokType = icon6_; nonCountingIntrQty++; }    	else if (tokeq("ICON7")) { tokType = icon7_; nonCountingIntrQty++; }    	else if (tokeq("ICON8")) { tokType = icon8_; nonCountingIntrQty++; }    	else if (tokeq("ICON9")) { tokType = icon9_; nonCountingIntrQty++; }    	else if (tokeq("PRINT")) { tokType = printNum_; nonCountingIntrQty++; }    	else if (tokeq("SYNC")) tokType = sync_;    	else if (tokeq("VSTORE")) tokType = vStore_;    	else if (tokeq("VRECALL")) tokType = vRecall_;    	else if (tokeq("DIST")) tokType = dist_;    	else if (tokeq("IFG")) tokType = ifg_;    	else if (tokeq("IFEG")) tokType = ifeg_;    	else if (tokeq("SND0")) { tokType = snd0_; nonCountingIntrQty++; }    	else if (tokeq("SND1")) { tokType = snd1_; nonCountingIntrQty++; }    	else if (tokeq("SND2")) { tokType = snd2_; nonCountingIntrQty++; }    	else if (tokeq("SND3")) { tokType = snd3_; nonCountingIntrQty++; }    	else if (tokeq("SND4")) { tokType = snd4_; nonCountingIntrQty++; }    	else if (tokeq("SND5")) { tokType = snd5_; nonCountingIntrQty++; }    	else if (tokeq("SND6")) { tokType = snd6_; nonCountingIntrQty++; }    	else if (tokeq("SND7")) { tokType = snd7_; nonCountingIntrQty++; }    	else if (tokeq("SND8")) { tokType = snd8_; nonCountingIntrQty++; }    	else if (tokeq("SND9")) { tokType = snd9_; nonCountingIntrQty++; }    	else if (tokeq("INTON")) tokType = inton_;    	else if (tokeq("INTOFF")) tokType = intoff_;    	else if (tokeq("RTI")) tokType = rti_;    	else if (tokeq("SETINT")) tokType = setint_;    	else if (tokeq("SETPARAM")) tokType = setparam_;    	else if (tokeq("MRB")) tokType=mrb_;    	else if (tokeq("DROPALL")) tokType = dropall_;    	else if (tokeq("FLUSHINT")) tokType = flushint_;    	else if (tokeq("MAX")) tokType = max_;    	else if (tokeq("MIN")) tokType = min_;    	else if (tokeq("ARCCOS")) tokType = arccos_;    	else if (tokeq("ARCSIN")) tokType = arcsin_;    	else if (tokeq("RECALL")) tokType = recall_;    	else if (isnumber()) tokType = atoi(token);    	else if ((val = islabel())) tokType = val;    	else if ((val = isvar())) tokType = val;    	if (tokType == unknown_) show_err("Unknown token",tokPtr);    	else if (tokType >= 20300 && tokType < 20500) codevar(tokType);    	else if (tokType == null_) ; /* ignore */    	else if (progPtr == errorInstruction) show_bug(tokPtr);    	else prog[progPtr++] = tokType;    	    	WEGetSelection( &selStart, &selEnd, myWText );    	if (bufPtr-1 < selStart) selStartPtr = progPtr;    	if (bufPtr-1 <= selEnd) selEndPtr = progPtr;    }}void compile(short errorInstruction){    char c;		/* Character read from file */		nonCountingIntrQty = 0;	    while (bufPtr < info.length && !errFlag  && !bugFlag && progPtr < (nonCountingIntrQty+progMaxSize-1) && (nonCountingIntrQty < 1000)) {     	c = WEGetChar(bufPtr++, myWText);    	if (isdelim(c)) {    		token[tokPtr] = '\0';    		parse_token(errorInstruction);    		if (isnewdelim(c)) {    			tokPtr = 0;    			token[tokPtr++] = c;    			token[tokPtr] = '\0';    			parse_token(errorInstruction);    		}    		if (c == '\r') lineNum++;    		tokPtr = 0;    	}    	else if (isprint(c)) token[tokPtr++] = c;    	if (progPtr >= (progMaxSize-1)) progPtr++;    }    token[tokPtr] = '\0';    if (!isdelim(token[0])) parse_token(errorInstruction);    //+= DelAllMenuItems( labelMenu );    //+= AddLabelsToMenu( lib, libPtr, labelMenu, -1 );        //SyntaxColorRange( 0, WEGetTextLength( myWText ), myWText ); //---n 15/4/98}void write_object(void){	short i;	unsigned long dateTime;	Handle res1,res2,res3;	long **aRes;	short	**bRes,**cRes;	short refNum;    GetDateTime(&dateTime);	prog[progPtr++] = end_; /* Affix end of program token */	setVolume(rob[botSelected].vRefNum);	CreateResFile(rob[botSelected].name);	if ((refNum = OpenResFile(rob[botSelected].name)) == -1)		reportMessage ("Error writing robot resources","");	else {		if ((res1 = GetResource('DATE',asmDateID)) != NULL) {			RemoveResource(res1);			checkResErr("AssemblyLine:write_object:1");			DisposeHandle(res1);		}		if ((res2 = GetResource('RCOD',robotCodeID)) != NULL) {			RemoveResource(res2);			checkResErr("AssemblyLine:write_object:2");			DisposeHandle(res2);		}		if ((res3 = GetResource('RLEN',codeLengthID)) != NULL) {			RemoveResource(res3);			checkResErr("AssemblyLine:write_object:3");			DisposeHandle(res3);		}				aRes = (long**)NewHandle(4L);		checkMemErr("AssemblyLine:write_object:1");		(*aRes)[0] = dateTime;		AddResource((Handle)aRes,'DATE',asmDateID,"\pAssembly");		checkResErr("AssemblyLine:write_object:4");				bRes = (short**)NewHandle(2L);		checkMemErr("AssemblyLine:write_object:2");		(*bRes)[0] = progPtr;		AddResource((Handle)bRes,'RLEN',codeLengthID,"\pCode Length");		checkResErr("AssemblyLine:write_object:5");					cRes = (short**)NewHandle(progPtr*2);		checkMemErr("AssemblyLine:write_object:3");		for (i=0; i<progPtr; i++)			(*cRes)[i] = prog[i];		AddResource((Handle)cRes,'RCOD',robotCodeID,"\pRobot Code");		checkResErr("AssemblyLine:write_object:6");					CloseResFile (refNum);	}	restoreVolume();	info.asmDate = dateTime;	info.codeLength = progPtr;}   			