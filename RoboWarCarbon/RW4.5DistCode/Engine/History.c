/* History.c *//* Written 3/19/95 by David Harris *//* This file contains functions to support the history   registers introduced in RoboWar 4.1. *//* #includes */#include <Carbon/Carbon.h>#include "RoboTypes.h"/* Constants */#define historyTop		70#define historyLeft		105#define historyRowSize	15/* Globals *//* External Variables */extern	short			numBots;			extern	robot			rob[maxBots];extern	long			chronons;extern	short			rosterChanged;extern	WindowPtr		myWindow;/* Prototypes */void clearHistory(void);void showHistory(void);void initHistory(void);void updateHistory(void);/* in Arena.c */short countTeammates(robot *who);/* in Util.c */extern void installButtonOutline(DialogPtr theDialog,short itemNo);/* Functions */void clearHistory(void){	rosterChanged = 1;}void showHistory(void){	DialogPtr myDialog;	short itemHit,i,row,rowNum,historyColSize;	char oldLen;	Str255 msg;		myDialog = GetNewDialog(HistoryDlogID,NULL,(WindowPtr)-1);	DrawDialog(myDialog);	SetPort(myDialog);	installButtonOutline(myDialog,2);	TextFont (kFontIDMonaco); TextSize(9);	historyColSize = 390 / numBots;		sprintf ((char*)msg,"History of previous rounds");	CtoPstr((char*)msg);	MoveTo (240-StringWidth(msg)/2,15); DrawString(msg);	sprintf ((char*)msg,"%hd Battles so far in %hd chronons",		rob[0].history[0],rob[0].history[10]);	CtoPstr((char*)msg);	MoveTo (240-StringWidth(msg)/2,25); DrawString(msg);	sprintf	((char*)msg,"Last battle %s after %hd chronons",		rob[0].history[5] ? "timed out" : "ended", rob[0].history[9]);	CtoPstr((char*)msg);	MoveTo (240-StringWidth(msg)/2,35); DrawString(msg);	sprintf ((char*)msg,"B: Last Battle    T: Total");	CtoPstr((char*)msg);	MoveTo (240-StringWidth(msg)/2,45); DrawString(msg);		// - Draw main lines in history	PenSize(2,2);	MoveTo (0,historyTop+2); 	LineTo (500,historyTop+2);	MoveTo (historyLeft-3,historyTop-10); 	LineTo (historyLeft-3,historyTop+7*historyRowSize);	PenSize(1,1);		rowNum = 0;	for (row = 0; row < 12; row++) {		if (row != 0 && row != 1 && row != 6 && row != 10 && row != 11) {			rowNum++;			for (i=0; i<numBots; i++) {				MoveTo (historyLeft+i*historyColSize,historyTop+rowNum*historyRowSize);				sprintf((char*)msg,"%hd",rob[i].history[row-1]);				CtoPstr((char*)msg);				DrawString(msg);			}		}		switch (row) {			case 0:	MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\pHistory Register");					for (i=0; i<numBots; i++) {						MoveTo (historyLeft+i*historyColSize,historyTop+row*historyRowSize);						oldLen = rob[i].name[0];						if (oldLen > historyColSize/7) rob[i].name[0] = historyColSize/7;						DrawString(rob[i].name);						rob[i].name[0] = oldLen;					}					break;			case 2: MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\p2: B Kills");					break;			case 3: MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\p3: T Kills");					break;			case 4: MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\p4: B Survival");					break;			case 5: MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\p5: T Survival");					break;			case 7: MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\p7: B Teammates");					break;			case 8: MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\p8: T Teammates");					break;			case 9: MoveTo (5,historyTop+rowNum*historyRowSize);					DrawString("\p9: B Damage");					break;		}	}	do {		ModalDialog(NULL,&itemHit);	} while (itemHit != 1);	TextFont(systemFont); TextSize(12);	SetPort(myWindow);	DisposeDialog(myDialog);}void initHistory(void){	short i,j;		if (rosterChanged) {		rosterChanged = 0;		for (i=0; i<numBots; i++) 			for (j=0; j<historySize; j++)				rob[i].history[j] = 0;	}}void updateHistory(void){	short i,k,max,next,alive;		/* Count survival points & check for ties */	/* Change this code if group scoring system changes */	max = 0; next = 0; alive=0;	for (k=0; k<numBots; k++) {		if (rob[k].deathTime > max) {			max = rob[k].deathTime;		}		if (rob[k].alive) alive++;	}	for (k=0; k<numBots; k++) {		if (rob[k].deathTime > next && rob[k].deathTime != max) {			next = rob[k].deathTime;		}	}	for (i=0; i<numBots; i++) {		rob[i].history[0]++;		rob[i].history[1] = rob[i].kills;		rob[i].history[2] += rob[i].kills;		//if (numBots > 2) {		//	if (rob[i].alive) rob[i].history[3] = 3;		//	else if (rob[i].deathTime == max) rob[i].history[3] = 2;		//	else if (rob[i].deathTime == next) rob[i].history[3] = 1;		//	else rob[i].history[3] = 0;		//}		//else rob[i].history[3] = rob[i].alive;		rob[i].history[3] = rob[i].svrl;		rob[i].history[4] += rob[i].history[3];		rob[i].history[5] = alive > 1;		rob[i].history[6] = countTeammates(rob+i);		rob[i].history[7] += rob[i].history[6];		rob[i].history[8] = rob[i].alive ? rob[i].damage : 0;		rob[i].history[9] = (short)chronons;		rob[i].history[10] += (short)chronons;	}}