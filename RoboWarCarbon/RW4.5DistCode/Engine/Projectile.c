/* Projectile.c *//* Written 8/16/93 by David Harris	This file contains procedures related to firing weapons	that were originally contained in Arena.c.*//* #includes */#include <Carbon/Carbon.h>#include "robotypes.h"#include "Tokens.h"/* External Globals */extern	double			sine[360];extern	short			numBots;			extern	robot			rob[maxBots];		extern	shot			*shots;		extern	robot 			*who;extern 	short			isTournament;extern	short			officialFlag;extern	prefStruct		gPrefs;		/* Prototypes */short findTarget(void);short findLaserTarget(double *x,double *y);shot *newShot(BYTE type);void doGun(short what);void doMissile (short what);void doNuke (short what);void doJoce(short what);void doHellBore(short what);void doDrone(short what,short target);void doMine(short what);void doLaser(short what,double x,double y,short target);void doBullet(short what);void doStunner(short what);short distance(robot *who);short radar(robot *who);short doppler(void);short approach(void);/* in Arena.c */extern void robotError(char *type, Boolean KillRobotQ);extern void	checkLegalEnergyDecrement(short what);// utils.cextern void reportMessage(char *message1,char *message2);/* Functions */short findTarget(void) /* For finding drone targets */{	short i,dist = 0,target = maxBots;	double m,n,t;  				/* x=mt + x', y=nt + y' */								/* for paramaterized line of fire */	register long a,b,c,d;		/* coordinates of robots */		m = sine[(who->aim+who->look+270)%360];	n = -sine[(who->aim+who->look)%360];	a = who->letters[x_];	b = who->letters[y_];	for (i=0; i< numBots; i++)		if (rob[i].alive && i != who->number) {			c = rob[i].letters[x_];			d = rob[i].letters[y_];			t = (m*c + n*d - m*a -n*b)/(m*m+n*n);			if (t > 0 &&				(m*t+a-c)*(m*t+a-c)+				(n*t+b-d)*(n*t+b-d)< 				(radiusSquared-9)) /* in sights */				if (dist == 0 || t < dist) {					dist = (short)t;					target = i;				}		}	if (who->team && who->team == rob[target].team)	 	dist = 0;		/* Don't shoot own team member */	if (dist) return target;	else return -1;}short findLaserTarget(double *x,double *y){	short i,dist = 0,target = maxBots;	double m,n,t;  		/* x=mt + a, y=nt + b */						/* for paramaterized line of fire */	register long a,b,c,d;		/* coordinates of robots */	m = sine[(who->aim+who->look+270)%360];	n = -sine[(who->aim+who->look)%360];	a = who->letters[x_];	b = who->letters[y_];	for (i=0; i< numBots; i++)		if (rob[i].alive && i != who->number) {			c = rob[i].letters[x_];			d = rob[i].letters[y_];			t = (m*c + n*d - m*a -n*b)/(m*m+n*n);			if (t > 0 &&				(m*t+a-c)*(m*t+a-c)+				(n*t+b-d)*(n*t+b-d)< 				(radiusSquared-9)) /* in sights */				if (dist == 0 || t < dist) {					dist = (short)t;					*x = m*t + a;					*y = n*t + b;					target = i;				}		}	if (who->team && who->team == rob[target].team)	 	dist = 0;		/* Don't shoot own team member */	if (dist) return target;	else return -1;}shot *newShot(BYTE type){	register shot *cur;	cur = shots;		if (cur != NULL) {		while (cur->next != NULL) cur = cur->next;		cur->next = (shot*)NewPtr(sizeof(shot));		cur = cur->next; /* Move to new element */	}	else {		shots = (shot*)NewPtr(sizeof(shot));		cur = shots;	}	cur->type = type;	cur->owner = who->number;	cur->next = NULL;	cur->soundFlag = 1;		return cur;}void doGun(short what){	register shot *cur;	register double x,y;	if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )		robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false );	if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )	{		cur = newShot(gun);		x = sine[(270+who->aim)%360];		y = -sine[who->aim];		cur->xPos = who->letters[x_]+x*(radius+1);		cur->yPos = who->letters[y_]+y*(radius+1);		cur->xPosInt = cur->xPos;		cur->yPosInt = cur->yPos;		cur->xAngle = x*6.0;		cur->yAngle = y*6.0;		cur->gunType = who->hardware.gunType;				if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		checkLegalEnergyDecrement(what);		cur->energy = what;		//who->energy -= what;				who->haveDoneMoveOrShootQ = 1;	}		if (what > who->hardware.energyMax) what = who->hardware.energyMax;	if (who->hardware.noNegEnergy && what > who->energy) 		what = who->energy;	checkLegalEnergyDecrement(what);	who->energy -= what;}void doMissile (short what){	register shot *cur;	register double x,y;		if (!who->hardware.missileFlag) 		robotError("Missiles not enabled.",true);	else {			if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false );					if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(missile);			x = sine[(270+who->aim)%360];			y = -sine[who->aim];			cur->xPos = who->letters[x_]+x*(radius+1);			cur->yPos = who->letters[y_]+y*(radius+1);			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->xAngle = x*5;			cur->yAngle = y*5;			if (fabs(cur->xAngle) < 0.001) cur->xAngle = 0;			if (fabs(cur->yAngle) < 0.001) cur->yAngle = 0;			cur->gunType = missile;			cur->soundFlag = 1;						if (what > who->hardware.energyMax) what = who->hardware.energyMax;			if (who->hardware.noNegEnergy && what > who->energy) 				what = who->energy;			checkLegalEnergyDecrement(what);			cur->energy = what;			//who->energy -= what;					who->haveDoneMoveOrShootQ = 1;		}				if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		checkLegalEnergyDecrement(what);		who->energy -= what;	}}void doNuke (short what) /* TacNuke!!!! */{	register shot *cur;	if (!who->hardware.tacNukeFlag) 		robotError("TacNukes not enabled.",true);	else {		if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost", false );		if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(tacNuke);			cur->xPos = who->letters[x_];			cur->yPos = who->letters[y_];			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->xAngle = 0; /* stage of device */			cur->yAngle = 0;			cur->gunType = tacNuke;			cur->soundFlag = 0;						if (what > who->hardware.energyMax) what = who->hardware.energyMax;			if (who->hardware.noNegEnergy && what > who->energy) 				what = who->energy;			checkLegalEnergyDecrement(what);			cur->energy = what;			//who->energy -= what;					who->haveDoneMoveOrShootQ = 1;		}				if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		checkLegalEnergyDecrement(what);		who->energy -= what;	}}void doJoce(short what){#pragma unused (what)	register shot *cur;	if (isTournament && officialFlag) robotError ("No undocumented commands in tournaments",true);	else {		cur = newShot(tacNuke);		cur->xPos = who->letters[x_];		cur->yPos = who->letters[y_];		cur->xPosInt = cur->xPos;		cur->yPosInt = cur->yPos;		cur->xAngle = 0; /* stage of device */		cur->yAngle = 0;		cur->gunType = tacNuke;		cur->soundFlag = 0;		cur->energy = 200;		who->damage = 0;	}}void doHellBore(short what){	register shot *cur;	register double x,y;	if (!who->hardware.hellboreFlag) 		robotError("Hellbores not enabled.",true);	else {		if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false );			if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(hellBore);			x = sine[(270+who->aim)%360];			y = -sine[who->aim];			cur->xPos = who->letters[x_]+x*(radius+1);			cur->yPos = who->letters[y_]+y*(radius+1);			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->xAngle = x*what/2.0;			cur->yAngle = y*what/2.0;			cur->gunType = hellBore;			cur->soundFlag = 1;						if (what > who->hardware.energyMax) what = who->hardware.energyMax;			if (who->hardware.noNegEnergy && what > who->energy) 				what = who->energy;			cur->energy = what;			checkLegalEnergyDecrement(what);			//who->energy -= what;					who->haveDoneMoveOrShootQ = 1;		}				if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		checkLegalEnergyDecrement(what);		who->energy -= what;	}}void doDrone(short what,short target){	register double x,y;	register shot *cur;		if (isTournament && officialFlag) robotError ("No undocumented commands in tournaments",true);	else if (gPrefs.rules_noDrones) robotError ("Robots are not allowed to use Drones",true);	else if (!who->hardware.droneFlag) robotError("Drones not enabled.",true);	else {		if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false );		if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(drone);			x = sine[(270+who->aim)%360];			y = -sine[who->aim];			cur->xPos = who->letters[x_]+x*(radius+1);			cur->yPos = who->letters[y_]+y*(radius+1);			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->xAngle = 100; /* Life span of drone */			cur->yAngle = target; /* Target robot */			cur->gunType = drone;			cur->soundFlag = 1;			cur->gunType = 1;						if (what > who->hardware.energyMax) what = who->hardware.energyMax;			if (who->hardware.noNegEnergy && what > who->energy) 				what = who->energy;			cur->energy = what;			checkLegalEnergyDecrement(what);			//who->energy -= what;					who->haveDoneMoveOrShootQ = 1;		}		if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		checkLegalEnergyDecrement(what);		who->energy -= what;	}}void doMine(short what){	register shot *cur;	if (!who->hardware.mineFlag) 		robotError("Mines not enabled.",true);	else {			if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false );		if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy)			what = who->energy;		if (what < 6)			return;				if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(newMine);			cur->xPos = who->letters[x_];			cur->yPos = who->letters[y_];			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->xAngle = 10; /* stage of device */			cur->yAngle = 0;			cur->soundFlag = 1;						cur->energy = what - 5;			checkLegalEnergyDecrement(what);			//who->energy -= what;						who->haveDoneMoveOrShootQ = 1;		}		checkLegalEnergyDecrement(what);		who->energy -= what;	}}void doLaser(short what,double x,double y,short target){	register shot *cur;	short	tmp;	if (isTournament && officialFlag) robotError ("No undocumented commands in tournaments",true);	else if (gPrefs.rules_noLazers) robotError ("Robots are not allowed to use Lazers",true);	else if (!who->hardware.laserFlag) robotError("Lasers not enabled.",true);	else {			if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false);		if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(laser);			cur->gunType = target;			cur->xAngle = x;			cur->yAngle = y;			x = sine[(270+who->aim)%360];			y = -sine[who->aim];			cur->xPos = who->letters[x_]+x*(radius+1);			cur->yPos = who->letters[y_]+y*(radius+1);			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->soundFlag = 1;								if (what > who->hardware.energyMax) what = who->hardware.energyMax;			if (who->hardware.noNegEnergy && what > who->energy) 				what = who->energy;			tmp = who->energy;			if (tmp < 0) tmp = 0;			checkLegalEnergyDecrement(what);			//who->energy -= what;			if (what > tmp) what = tmp;			cur->energy = what;					who->haveDoneMoveOrShootQ = 1;		}				if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		tmp = who->energy;		if (tmp < 0) tmp = 0;		checkLegalEnergyDecrement(what);		who->energy -= what;	}}void doBullet(short what){	register shot *cur;	register double x,y;	if (who->hardware.gunType == 1) 		robotError("Normal bullets not available.",true);	else {		if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false );		if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(gun);			x = sine[(270+who->aim)%360];			y = -sine[who->aim];			cur->xPos = who->letters[x_]+x*(radius+1);			cur->yPos = who->letters[y_]+y*(radius+1);			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->xAngle = x*6.0;			cur->yAngle = y*6.0;			cur->gunType = 2; /* Fire normal bullet */			cur->soundFlag = 1;						if (what > who->hardware.energyMax) what = who->hardware.energyMax;			if (who->hardware.noNegEnergy && what > who->energy) 				what = who->energy;			cur->energy = what;			checkLegalEnergyDecrement(what);			//who->energy -= what;					who->haveDoneMoveOrShootQ = 1;		}		if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		checkLegalEnergyDecrement(what);		who->energy -= what;	}}void doStunner(short what){	register shot *cur;	register double x,y;	if (!who->hardware.stunnerFlag) 		robotError("Stunners not enabled.",true);	else {		if( gPrefs.rules_noMoveShoot && who->haveDoneMoveOrShootQ == 2 && gPrefs.showMoveAndShootAlert )			robotError( "A Robot can't move and shoot in the same chronon, energy for the second operation is lost",false );		if( (!gPrefs.rules_noMoveShoot) || who->haveDoneMoveOrShootQ != 2 )		{			cur = newShot(stunner);			x = sine[(270+who->aim)%360];			y = -sine[who->aim];			cur->xPos = who->letters[x_]+x*(radius+1);			cur->yPos = who->letters[y_]+y*(radius+1);			cur->xPosInt = cur->xPos;			cur->yPosInt = cur->yPos;			cur->xAngle = x*7.0;			cur->yAngle = y*7.0;			cur->gunType = stunner;			cur->soundFlag = 1;							if (what > who->hardware.energyMax) what = who->hardware.energyMax;			if (who->hardware.noNegEnergy && what > who->energy) 				what = who->energy;			cur->energy = what;			checkLegalEnergyDecrement(what);			//who->energy -= what;						who->haveDoneMoveOrShootQ = 1;		}		if (what > who->hardware.energyMax) what = who->hardware.energyMax;		if (who->hardware.noNegEnergy && what > who->energy) 			what = who->energy;		checkLegalEnergyDecrement(what);		who->energy -= what;	}}short distance(robot *who){	short i,dist = 0,target = maxBots;	double m,n,t;  		/* x=mt + x', y=nt + y' */						/* for paramaterized line of fire */	register long a,b,c,d;		/* coordinates of robots */	/* Range algorithm:  see what robots intersect line of sight.			t = distance along line of sight closest to target being checked		m = cos (angle)		n = sin (angle)				1) Compute t, distance along aim vector		2) Use crude check to see if target is in general area		3) Use precise formula to see if robot circle is hit	*/		m = sine[(who->aim+who->look+270)%360];	n = -sine[(who->aim+who->look)%360];	a = who->letters[x_];	b = who->letters[y_];	for (i=0; i< numBots; i++)		if (rob[i].alive && i != who->number) {			c = rob[i].letters[x_];			d = rob[i].letters[y_];			t = m*(c-a) + n*(d-b);	 		if (t > 0 && fabs((m+n)*t+a+b-c-d) < 20) /* First a crude Manhatten Metric check */				if ( (m*t+a-c)*(m*t+a-c) + (n*t+b-d)*(n*t+b-d) < (radiusSquared-9)) /* in sights */					if (dist == 0 || t < dist) {						dist = (short)t;						target = i;					}		}	if (who->team && who->team == rob[target].team)	 	dist = 0;		/* Don't shoot own team member */	return dist;}short radar(robot *who){	register shot *cur;	register short x,y,theta,scan;	long range,close = 1000000,result;		cur = shots;	x = who->letters[x_];	y = who->letters[y_];	scan = (who->aim+who->scan)%360;	while (cur != NULL) {		if (cur->type != laser) {			theta = (short)(450-atan2(y-cur->yPosInt,cur->xPosInt-x)*radToDeg)%360;			if ((abs(theta-scan) < 20) || (abs(theta-scan) > 340)) {				range = (y-cur->yPosInt)*(long)(y-cur->yPosInt) + 						(x-cur->xPosInt)*(long)(x-cur->xPosInt);				if (range < close) close = range;			}		}		cur = cur->next;	}	if (close == 1000000) result = 0;	else result = sqrt(close);	return result;}short doppler(void){	short i,dist = 0,target = maxBots;	double m,n,t;  		/* x=mt + x', y=nt + y' */						/* for paramaterized line of fire */	register long a,b,c,d;		/* coordinates of robots */	double tmp;	long doppler;		/* Doppler computes the velocity of the robot detected by range perpendicular		to the aim vector.  It neglects any movement of the tracking robot.				Doppler first finds the nearest robot in sight, if there is one.  Then it		uses the following formula to compute perpendicular velocity:  		(v = velocity vector of target, r = vector from tracker to target)				             ------------------		            /          (r¥v)^2		dop = ± \  /  |v|^2  - -------		         \/             |r|^2				where the sign is positive if r x v ³ 0 (or maybe the other way round).	*/		       	m = sine[(who->aim+who->look+270)%360];	n = -sine[(who->aim+who->look)%360];	for (i=0; i< numBots; i++)		if (rob[i].alive && i != who->number) {			a = who->letters[x_];			b = who->letters[y_];			c = rob[i].letters[x_];			d = rob[i].letters[y_];			t = (m*c + n*d - m*a -n*b); /* /(m*m+n*n) deleted because it seems to equal 1 */			if (t > 0 &&				(m*t+a-c)*(m*t+a-c)+				(n*t+b-d)*(n*t+b-d)< 				(radiusSquared-9)) /* in sights */				if (dist == 0 || t < dist) {					dist = (short)t;					target = i;					if (rob[target].energy < 0 || rob[target].stunned ||						rob[target].collision || rob[target].wall) doppler = 0;					else {						a = (a-c); /* a = rx */						b = (b-d); /* b = ry */						c = (a*rob[target].speedX + b*rob[target].speedY); /* c = r¥v */						t = (rob[target].speedX*rob[target].speedX+							 rob[target].speedY*rob[target].speedY) -							 (double)(c*c) / (double)(a*a+b*b);						tmp = sqrt(t);						if (tmp-(long)tmp > 0.5) tmp+=1.0;						doppler = (a*rob[target].speedY-b*rob[target].speedX) > 0 ?							-tmp : tmp;					}				}		}	if (who->team && who->team == rob[target].team)	 	dist = 0;  /* Don't shoot own team member */	return dist==0 ? 0 : doppler;}// ---// Approach computes the speed at which the robot's are moving towards the viewing robot// Note: I've used the approach code but swpaped x and y hence dopppler -> approach// ---short approach(void){	short i,dist = 0,target = maxBots;	double m,n,t;  		/* x=mt + x', y=nt + y' */						/* for paramaterized line of fire */	register long a,b,c,d;		/* coordinates of robots */	double tmp;	long doppler;		/* Doppler computes the velocity of the robot detected by range perpendicular		to the aim vector.  It neglects any movement of the tracking robot.				Doppler first finds the nearest robot in sight, if there is one.  Then it		uses the following formula to compute perpendicular velocity:  		(v = velocity vector of target, r = vector from tracker to target)				             ------------------		            /          (r¥v)^2		dop = ± \  /  |v|^2  - -------		         \/             |r|^2				where the sign is positive if r x v ³ 0 (or maybe the other way round).	*/		       	m = sine[(who->aim+who->look+270)%360];	n = -sine[(who->aim+who->look)%360];	for (i=0; i< numBots; i++)		if (rob[i].alive && i != who->number) {			a = who->letters[x_];			b = who->letters[y_];			c = rob[i].letters[y_];			d = -rob[i].letters[x_];			t = (m*c + n*d - m*a -n*b); /* /(m*m+n*n) deleted because it seems to equal 1 */			if (t > 0 &&				(m*t+a-c)*(m*t+a-c)+				(n*t+b-d)*(n*t+b-d)< 				(radiusSquared-9)) /* in sights */				if (dist == 0 || t < dist) {					dist = (short)t;					target = i;					if (rob[target].energy < 0 || rob[target].stunned ||						rob[target].collision || rob[target].wall) doppler = 0;					else {						a = (a-c); /* a = rx */						b = (b-d); /* b = ry */						c = (a*rob[target].speedX + b*rob[target].speedY); /* c = r¥v */						t = (rob[target].speedX*rob[target].speedX+							 rob[target].speedY*rob[target].speedY) -							 (double)(c*c) / (double)(a*a+b*b);						tmp = sqrt(t);						if (tmp-(long)tmp > 0.5) tmp+=1.0;						doppler = (a*rob[target].speedY-b*rob[target].speedX) > 0 ?							-tmp : tmp;					}				}		}	if (who->team && who->team == rob[target].team)	 	dist = 0;  /* Don't shoot own team member */	return dist==0 ? 0 : doppler;}