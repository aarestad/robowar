//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥ FileName: PrefsDialog.c //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// Written: 16/4/98 by Lucas Dixon//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=////	This file contains routines for handling the prefs dialog////-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥ includes #include <Carbon/Carbon.h>#include "robotypes.h"//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥ Local Global Data// ---const	cPrefsDialogID	=	2001;	const Rect cMainSyntxColBox 	= {48,208,64,224};	const Rect cLabelSyntxColBox 	= {64,208,80,224};	const Rect cCommentSyntxColBox 	= {80,208,96,224};RGBColor	mainBoxC;RGBColor	labelBoxC;RGBColor	commentBoxC;Handle		controls[10];long		saveAsType;//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥ Extern Vars// --- Main.cextern prefStruct			gPrefs;	extern WindowPtr 			myWindow;extern macFeatures			features;extern MenuHandle			myMenus[9];//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥ Function Defs// ---void 		DoPrefsDialog(void);Boolean 	MyEventFilter(DialogPtr theDialog, short* itemHit);RGBColor 	MyDoColourSelect(RGBColor selectedColor);void 		DrawDialogColorBoxs(DialogPtr theDialog);void 		doSaveAsMenuSelect();short 		GetMenuItemFromSaveAsType();void		SetSaveAs(long inSaveAs );long		doCustomSaveAsDialog();//void 		AllMenusOff(void);//pascal Boolean (*ModalFilterProcPtr)(DialogPtr, EventRecord*, short*);//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥ extern Function Defs// --- util.cextern void reportMessage(char *message1,char *message2);extern void installButtonOutline(DialogPtr theDialog,short itemNo);// --- main.c extern void updateEvent(void);extern void doSetMaxPoints(void);extern void activateRoboWar(void);// --- defines for dialogItem ID's#define kDItem_tourneyLogQ		6#define kDItem_MaxHWP_Btn		21#define kDItem_MaxHWP_Txt		7#define kDItem_SyntaxColourQ	8#define kDItem_BuggyBotDQ		19#define KDItem_OKBtn			1#define kDItem_CancelBtn		2#define kDItem_TCreatorTypeM	23#define kDItem_TCreatorTypeT	22#define kDItem_MoveAndShootQ	25// --- define control items in array#define kCItem_tourneyLogQ		0#define kCItem_MaxHWP_Btn		1#define kCItem_MaxHWP_Txt		6#define kCItem_SyntaxColourQ	2#define kCItem_BuggyBotDQ		5#define kCItem_OKBtn			3#define kCItem_CancelBtn		4#define kCItem_TCreatorTypeM	7#define kCItem_TCreatorTypeT	8#define kCItem_MoveAndShootQ	9//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥// ---void DoPrefsDialog(void){	DialogPtr		theDialog;	Boolean			allDone=false;	short			ItemHit;	//long			tmpLong;	Rect			controlRect;	short			theItemType;		Str255			string;	//Point 			mousePos;			//myeventLoop = MyEventFilter;	// turn off menu bar		// - Get prefs data from prefs struct	commentBoxC	= gPrefs.commentColor;	labelBoxC = gPrefs.labelColor;	mainBoxC = gPrefs.mainTextColor;	saveAsType = gPrefs.tournyCreatorType;		// - make the dialog box	theDialog = GetNewDialog(cPrefsDialogID, 0L, (WindowPtr)-1L);		// - get handles to the dialog items	GetDialogItem(theDialog, kDItem_tourneyLogQ, &theItemType, &(controls[kCItem_tourneyLogQ]), &controlRect);	// tourney log	GetDialogItem(theDialog, kDItem_MaxHWP_Btn, &theItemType, &(controls[kCItem_MaxHWP_Btn]), &controlRect);	// max HW points Btn	GetDialogItem(theDialog, kDItem_MaxHWP_Txt, &theItemType, &(controls[kCItem_MaxHWP_Txt]), &controlRect);	// max HW points Txt	GetDialogItem(theDialog, kDItem_SyntaxColourQ, &theItemType, &(controls[kCItem_SyntaxColourQ]), &controlRect);	// syntax colouring	GetDialogItem(theDialog, kDItem_BuggyBotDQ, &theItemType, &(controls[kCItem_BuggyBotDQ]), &controlRect);	// Show Dialog On Buggy Robots	GetDialogItem(theDialog, kDItem_TCreatorTypeM, &theItemType, &(controls[kCItem_TCreatorTypeM]), &controlRect); 	// Tourney Creator Type	GetDialogItem(theDialog, kDItem_TCreatorTypeT, &theItemType, &(controls[kCItem_TCreatorTypeT]), &controlRect); 	// Tourney Creator Type Text	GetDialogItem(theDialog, kDItem_MoveAndShootQ, &theItemType, &(controls[kCItem_MoveAndShootQ]), &controlRect);	// Show Dialog On Buggy Robots		GetDialogItem(theDialog, KDItem_OKBtn, &theItemType, &(controls[kCItem_OKBtn]), &controlRect);	// ok btn	GetDialogItem(theDialog, kDItem_CancelBtn, &theItemType, &(controls[kCItem_CancelBtn]), &controlRect);	// cancel btn	//GetDialogItem(theDialog, 11, &theItemType, &(controls[kCItem_BuggyBotDQ]), &controlRect);	// comments col		// set static text of max HW points to the value	NumToString( gPrefs.maxPoints, string );	SetDialogItemText( controls[kCItem_MaxHWP_Txt], string );		// - set the saveas box	SetSaveAs(saveAsType);		// set the on/off selection boxes	SetControlValue( (ControlHandle)controls[kCItem_tourneyLogQ], gPrefs.createTournyLogQ);	SetControlValue( (ControlHandle)controls[kCItem_SyntaxColourQ], gPrefs.syntaxColoringQ);	SetControlValue( (ControlHandle)controls[kCItem_BuggyBotDQ], gPrefs.showBugyRobotDialogQ);	SetControlValue( (ControlHandle)controls[kCItem_MoveAndShootQ], gPrefs.showMoveAndShootAlert);		// if we arn't showing buggy bot dialofs then we wont show one on move and shoot, so hidethe choice.	if( !GetControlValue((ControlHandle)controls[kCItem_BuggyBotDQ]) )	{		HideControl( (ControlHandle)controls[kCItem_MoveAndShootQ] );		SetControlValue((ControlHandle)controls[kCItem_MoveAndShootQ], false );	}		//kDItem_TCreatorTypeM	// - Create the menu for selecting creator types to save text files as.	(ControlHandle)controls[kCItem_TCreatorTypeM] = GetNewControl(4001,theDialog);	SetControlValue( (ControlHandle)controls[kCItem_TCreatorTypeM], GetMenuItemFromSaveAsType() );	ShowControl((ControlHandle)controls[kCItem_TCreatorTypeM]);	DrawControls( theDialog );		if( controls[kCItem_TCreatorTypeM] == nil )	{		reportMessage("There's a problem with the prefs dialog...",":PrefsDialog.c:DoPrefsDialog:0");		return;	}		DrawDialog(theDialog);	DrawDialogColorBoxs(theDialog);	//AllMenusOff();	while(!allDone)	{				//ModalDialog( (RoutineDescriptor*)MyEventFilter, &ItemHit );		//GetMouse( & mousePos )		if( MyEventFilter(theDialog,  &ItemHit) )		{			switch(ItemHit)			{				case 1:					//GetDialogItemText(controls[kCItem_MaxHWP_Btn], string );					//StringToNum(string, &tmpLong);					//if( (tmpLong > 0 && tmpLong < 100) )					//{						allDone = true;												// - set all the prefs						gPrefs.createTournyLogQ = GetControlValue((ControlHandle)controls[kCItem_tourneyLogQ]);						gPrefs.syntaxColoringQ 	= GetControlValue((ControlHandle)controls[kCItem_SyntaxColourQ]);						gPrefs.showBugyRobotDialogQ = GetControlValue((ControlHandle)controls[kCItem_BuggyBotDQ]);						gPrefs.showMoveAndShootAlert = GetControlValue((ControlHandle)controls[kCItem_MoveAndShootQ]);						//gPrefs.maxPoints = tmpLong;						gPrefs.commentColor = commentBoxC;						gPrefs.labelColor = labelBoxC;						gPrefs.mainTextColor = mainBoxC;						gPrefs.tournyCreatorType = saveAsType;												// set the svaeas type.						GetDialogItemText( controls[kCItem_TCreatorTypeT], string );						((char*)&saveAsType)[0] = string[1];						((char*)&saveAsType)[1] = string[2];						((char*)&saveAsType)[2] = string[3];						((char*)&saveAsType)[3] = string[4];						gPrefs.tournyCreatorType = saveAsType;						// Save Prefs					//}					//else					//	reportMessage("Enter number of points between:", "0 and 100");					break;									case 2:					allDone = true;					break;								case 21: // tourny log					doSetMaxPoints();					NumToString( gPrefs.maxPoints, string );					SetDialogItemText( controls[kCItem_MaxHWP_Txt], string );					break;								case kDItem_tourneyLogQ: // tourny log					SetControlValue((ControlHandle)controls[kCItem_tourneyLogQ], 1 - GetControlValue((ControlHandle)controls[kCItem_tourneyLogQ]) );					break;				case kDItem_SyntaxColourQ: // syntax colouring					SetControlValue((ControlHandle)controls[kCItem_SyntaxColourQ], 1 - GetControlValue((ControlHandle)controls[kCItem_SyntaxColourQ]) );					break;				case kDItem_BuggyBotDQ: // syntax colouring					SetControlValue((ControlHandle)controls[kCItem_BuggyBotDQ], 1 - GetControlValue((ControlHandle)controls[kCItem_BuggyBotDQ]) );					if( GetControlValue((ControlHandle)controls[kCItem_BuggyBotDQ]) )					{						ShowControl( (ControlHandle)controls[kCItem_MoveAndShootQ] );						SetControlValue((ControlHandle)controls[kCItem_MoveAndShootQ], true );					}					else					{						HideControl( (ControlHandle)controls[kCItem_MoveAndShootQ] );						SetControlValue((ControlHandle)controls[kCItem_MoveAndShootQ], false );					}					break;				case 9: // main text color					mainBoxC = MyDoColourSelect(mainBoxC);					break;				case 10: // label color					labelBoxC = MyDoColourSelect(labelBoxC);					break;				case 11: // comment color					commentBoxC = MyDoColourSelect(commentBoxC);					break;				case 24: // SaveeAsCreatorType Text					doSaveAsMenuSelect();					DrawControls( theDialog );					break;				case kDItem_MoveAndShootQ:					SetControlValue((ControlHandle)controls[kCItem_MoveAndShootQ], 1 - GetControlValue((ControlHandle)controls[kCItem_MoveAndShootQ]) );					break;				//case 22: // SaveeAsCreatorType Menu					//SysBeep(0);				//	break;			}		}	}		DisposeDialog(theDialog);	//DoOnMenuBar();	//AllMenusOn();	//activateRoboWar();}//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥// ---Boolean MyEventFilter(DialogPtr theDialog, short* itemHit){	//short eventHappened;	short part;	unsigned long finalTicks;	EventRecord theEvent;	WindowPtr	theWindow;	//short		tmpShort;		//if (features.hasWaitNextEvent) 	//eventHappened = WaitNextEvent(everyEvent,&theEvent,5,NULL);	//else {	//	SystemTask();	//	eventHappened = GetNextEvent(everyEvent,&theEvent);	//}		if( WaitNextEvent(everyEvent,&theEvent,5,NULL) )	{		//if(  theEvent.what == nullEvent )		//		DialogSelect( &theEvent, &theDialog, &tmpShort );		switch( theEvent.what )		{			case updateEvt:				if( ((WindowPtr)theEvent.message) == (WindowPtr)theDialog )				{					BeginUpdate(theDialog);						UpdateDialog(theDialog, theDialog->visRgn );						DrawDialogColorBoxs(theDialog);						// do update drawing					EndUpdate(theDialog);					return false;				}				else if( ((WindowPtr)theEvent.message) == myWindow )				{					updateEvent();					return false;				}				// update my private controls...				break;			//case activateEvt:			//	break;			case mouseDown:				part = FindWindow( theEvent.where, &theWindow );				if( theWindow != theDialog )					SysBeep(0);				else 				{					switch( part )					{						case inDrag:							DragWindow( theWindow, theEvent.where, &(**(GetGrayRgn())).rgnBBox);						case inContent:							return DialogSelect( &theEvent, &theDialog, itemHit );							break;												default:							return DialogSelect( &theEvent, &theDialog, itemHit );							break;					}				}				break;								//DoDialogSelectColors( theEvent.where, theDialog, itemHit );			case keyDown:			case autoKey:				if( (theEvent.message & charCodeMask) == '\n' )				{	// ok btn hit					HiliteControl((ControlHandle)controls[kCItem_OKBtn], true);					//finalTicks = TickCount() + 8;					Delay(8,&finalTicks);					HiliteControl((ControlHandle)controls[kCItem_OKBtn], false);					*itemHit = 1; // BAD BAD BAD! Should link it to the control, but it's too late!					return true;				}				else if( (theEvent.message & charCodeMask) == '.' && theEvent.modifiers & cmdKey )				{	// cancel btn hit					HiliteControl((ControlHandle)controls[kCItem_CancelBtn], true);					//finalTicks = TickCount() + 8;					Delay(8,&finalTicks);					HiliteControl((ControlHandle)controls[kCItem_CancelBtn], false);					*itemHit = 2; // BAD BAD BAD! Should link it to the control, but it's too late!					return true;				}				else					return DialogSelect( &theEvent, &theDialog, itemHit );				break;						default:				//theEvent.what = nullEvent;				//DialogSelect( &theEvent, &theDialog, &tmpShort );				//TEIdle();				//UpdateDialog(theDialog, theDialog->visRgn );				//DialogSelect( &theEvent, &theDialog, itemHit );				// update maxHWPoints box				//HiliteControl( (ControlHandle)controls[kCItem_MaxHWP_Btn], 0 );				return false;			//	return DialogSelect( &theEvent, &theDialog, itemHit );			//	break;					}	}	//else		//DialogSelect( &theEvent, &theDialog, &tmpShort );			return false;}//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥// ---void DrawDialogColorBoxs(DialogPtr theDialog){	WindowPtr	oldPort;	Rect r;			GetPort( &oldPort );	SetPort( theDialog );		r = cMainSyntxColBox;	ForeColor(blackColor);	FrameRect( &r );	InsetRect( &r, 2, 2 );	RGBForeColor( &mainBoxC );	PaintRect( &r );		r = cLabelSyntxColBox;	ForeColor(blackColor);	FrameRect( &r );	InsetRect( &r, 2, 2 );	RGBForeColor( &labelBoxC );	PaintRect( &r );	r = cCommentSyntxColBox;	ForeColor(blackColor);	FrameRect( &r );	InsetRect( &r, 2, 2 );	RGBForeColor( &commentBoxC );	PaintRect( &r );		ForeColor(blackColor);		SetPort( oldPort );}//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=// ¥// ---RGBColor MyDoColourSelect(RGBColor selectedColor){	Point		windowPos = { 50,20 };	RGBColor	theNewColor;		if( GetColor( windowPos, "\pChoose a color:", &selectedColor, &theNewColor ) )		return theNewColor;	else		return selectedColor;}//--- 27 july 98 --- new//void doSaveAsMenuSelect(){	//ControlHandle		controlHdl;	short				startControlValue, finishControlValue;	Boolean				nothandledEventQ = true;	Point				where;	long 				tmp;	//	GlobalToLocal( &where );	GetMouse(&where);	startControlValue = GetControlValue((ControlHandle)controls[kCItem_TCreatorTypeM]);	TrackControl((ControlHandle)controls[kCItem_TCreatorTypeM],where,(ControlActionUPP) -1);	finishControlValue = GetControlValue((ControlHandle)controls[kCItem_TCreatorTypeM]);		switch( finishControlValue )	{		case 1:	// teach text			SetSaveAs('ttxt');			break;		case 2: // BBEdit			SetSaveAs('R*ch');			break;		case 3: // Code Warrior			SetSaveAs('CWIE');			break;		case 4: // Claris Works			SetSaveAs('BOBO');			break;		case 6: // custom...			tmp = doCustomSaveAsDialog();			if( tmp != nil )				SetSaveAs( tmp );			else				SetControlValue( (ControlHandle)controls[kCItem_TCreatorTypeM], startControlValue );			break;	}}// ------------------------------------------------------------------------------------------//  Gets the ID of the menu item corresponding to the saveAs 4 character type.//  This is the oposite function of "doSaveAsMenuSelect()"short GetMenuItemFromSaveAsType(){	switch(saveAsType)	{		case 'ttxt': // simpletext is menu item 1			return 1;			break;		case 'R*ch': // BBEdit is menu item 2			return 2;			break;		case 'CWIE': // CodeWarrior is menu item 3			return 3;			break;		case 'BOBO': // ClrisWorks is menu item 4			return 4;			break;		default: // custom is menu item 6			return 6;			break;	}}void SetSaveAs(long inSaveAs){	Str255		string;		saveAsType = inSaveAs;		string[0] = 4;	string[1] = ((char*)&saveAsType)[0];	string[2] = ((char*)&saveAsType)[1];	string[3] = ((char*)&saveAsType)[2];	string[4] = ((char*)&saveAsType)[3];	SetDialogItemText( controls[kCItem_TCreatorTypeT], string );}long doCustomSaveAsDialog(){	#define	kDlogID_SaveAsType	4002		DialogPtr 	myDialog;	short 		itemHit,itemType;	Handle 		item;	Rect 		box;	Str255 		saveAsTypeStr;	long		saveAsLong;		myDialog = GetNewDialog(kDlogID_SaveAsType,NULL,(WindowPtr)-1);	installButtonOutline(myDialog,3);	//-sprintf((char*)pts,"%d",maxPoints);	//-CtoPstr((char*)pts);		// Get the current saveAstype as a string	saveAsLong = saveAsType;	saveAsTypeStr[0] = 4;	*((long*)(&saveAsTypeStr[1])) = saveAsLong;	// Setup the dialog's text	ParamText(saveAsTypeStr,"\p","\p","\p");	GetDialogItem(myDialog,6,&itemType,&item,&box);	SetDialogItemText(item,saveAsTypeStr);	SelectDialogItemText(myDialog,6,0,32767);	do {		ModalDialog(NULL,&itemHit);	} while (itemHit > 2);	if (itemHit == 1) {		GetDialogItemText(item,saveAsTypeStr);		if( saveAsTypeStr[0] > 4 )			reportMessage("A file type is only four characters,","Please enter a correct file type.");		else	// Set the saveas type			saveAsLong = *((long*)(&saveAsTypeStr[1]));	}	else if( itemHit == 2 )	{		saveAsLong = nil;	}	DisposeDialog(myDialog);		return saveAsLong;}/*--- worksvoid AllMenusOff(){	short i,j;	for( i = 0; i < kNumOfMenus; i++ )	{		for( j = CountMenuItems(myMenus[i]) -1; j >= 0; j-- )		{			DisableItem( myMenus[i], j );		}	}}*//*void AllMenusOn(){	shor i,j;	for( i = 1; i <= kNumOfMenus; i++ )	{		for( j = CountMenuItems(myMenus[i]); j > 0; j-- )		{			EnableItem( myMenus[i], j );		}	}}*/