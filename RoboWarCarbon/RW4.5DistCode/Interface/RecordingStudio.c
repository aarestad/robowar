/* RecordingStudio.c *//* Written 5/15/93 by David Harris 	This file handles recording sounds for a robot.		The encoding of sounds is slightly tricky since much memory would be	devoured if all robots kept their sounds in memory simultaneously.		Each robot has an array of 10 sound handles.  If a handle is NULL, no	sound is defined for that entry.  If the handle is valid but the	master pointer is NULL, the sound exists but must be read from the	resource file before use.  If the handle is valid and the master pointer	is valid, the sound is in memory, but should be purgable.		Therefore, all sounds should be checked before use and reloaded if	necessary.*//* #includes */#include <Carbon/Carbon.h>#include "robotypes.h"/* Variables */short					soundSelected;short					sndInDeskScrap;	/* 1 if there is a 'snd ' resource in desk scrap */Rect					recordingToolsRect[2];Handle					recordingToolsIcon[2];short					recordingToolsValid[2];ControlHandle			qualityButtons[3];		/* Radio buttons for recording quality */Handle					undoHandle;short					sndOnQ;/* External Variables */extern	short			controlChange;extern	EventRecord		myEvent;extern	WindowPtr		myWindow;extern	MenuHandle		myMenus[5];		extern 	CursHandle		watchCurs;extern	SndChannelPtr  	gChan;extern	macFeatures		features;	extern  robot			rob[maxBots];extern	short			numBots;extern	short			botSelected;extern 	short			modifyFlag;extern	Str255			noName;extern  short			sndQuality;extern prefStruct	gPrefs;				// preferences struct/* Prototypes */void adjustSoundMenus(void);void checkForSoundInScrap(void);void bringSoundToMemory(short bot,short snd);void getOldSound(void);void invalSounds(void);void updateRecording(void);void studioRecordSound(void);void studioPlaySound(void);void clickInRecordingTool(short which);void trackRecordingButton(ControlHandle what);void clickRecording(void);void setupRecordingTools(void);void initRecording(void);void closeRecording(void);void copySnd(void);void pasteSnd(Handle pasteSnd);void clearSnd(void);void cutSnd(void);void undoSnd(void);/* in Util.c */extern void reportMessage(char *message1,char *message2);extern void checkMemErr(char *proc);extern void checkResErr(char *proc);extern void checkSndErr(OSErr err,char *proc);extern void setVolume(short vRefNum);extern void restoreVolume(void);extern void playSound(short whichSound,short whichBot);extern void clearChannel(void);/* in IconFactory.c */extern void dimMenus(void);// --- in RecordingStudio.c ---extern void doSoundFlag(void);/* Functions */void adjustSoundMenus(void){	if (sndInDeskScrap) EnableItem(myMenus[2],paste_);	else DisableItem(myMenus[2],paste_);		if (rob[botSelected].sounds[soundSelected] != NULL) {		EnableItem(myMenus[2],cut_);		EnableItem(myMenus[2],copy_);		EnableItem(myMenus[2],clear_);	}	else {		DisableItem(myMenus[2],cut_);		DisableItem(myMenus[2],copy_);		DisableItem(myMenus[2],clear_);	}}void checkForSoundInScrap(void){	long offset;		sndInDeskScrap = (GetScrap(NULL,'snd ',&offset) >= 0);	adjustSoundMenus();}void bringSoundToMemory(short bot,short snd){	short refNum;	Handle res;	if (rob[bot].sounds[snd] == NULL) {		reportMessage ("Error:  Attempting to operate on","  sound that doesn't exist.");	}	else if (*(rob[bot].sounds[snd]) == NULL) {		setVolume(rob[bot].vRefNum);				CreateResFile(rob[bot].name);		if ((refNum = OpenResFile(rob[bot].name)) == -1)			reportMessage ("Error opening robot resources","");		else {			/* mem = MaxMem(&grow); */  /* Stress system by purging always */			res = GetResource('snd ',SoundID+snd);			if (ResError() != noErr && ResError() != resNotFound) SysBeep(1);			else if (res != NULL) {				rob[bot].sounds[snd] = res;				HandToHand(&rob[bot].sounds[snd]);				HPurge(rob[bot].sounds[snd]);				ReleaseResource(res);			}		}		CloseResFile (refNum);		restoreVolume();	}}void getOldSound(void){	if (undoHandle != NULL) DisposeHandle(undoHandle);	undoHandle = rob[botSelected].sounds[soundSelected];	if (undoHandle != NULL) {		HandToHand(&undoHandle);		HNoPurge(undoHandle);	}}void invalSounds(void){	Rect r;		r.top = 65; r.left = 25;	r.bottom = 85; r.right = 275;	InvalRect(&r);	InvalRect(&recordingToolsRect[0]);	r.top = ((short)(soundSelected/2))*45+18;	r.bottom = r.top + 34;	r.left = 333+(soundSelected%2)*100;	r.right = r.left + 34;	InvalRect(&r);}void updateRecording(void){	short i,j;	Rect r;	Str255 msg;	long size;		EraseRect(&myWindow->portRect);		TextFont(kFontIDMonaco);	TextSize(9);	for (i=0; i<5; i++) 		for (j=0; j<2; j++) {			if (rob[botSelected].sounds[i+i+j]) {				r.top = i*45+19;				r.bottom = i*45+51;				r.left = 334+j*100;				r.right = 366+j*100;				ForeColor(cyanColor);				FillRect(&r,&qd.gray);			}			ForeColor(greenColor);			if (i+i+j > 3)				sprintf((char*)msg,"Sound %d",i+i+j);			else if (i==0 && j==0) strcpy((char*)msg,"Death");			else if (i==0 && j==1) strcpy((char*)msg,"Collision");			else if (i==1 && j==0) strcpy((char*)msg,"Shield Hit");			else if (i==1 && j==1) strcpy((char*)msg,"Robot Hit");			CtoPstr((char*)msg);			MoveTo (350+j*100-StringWidth(msg)/2,i*45+61);			DrawString (msg);		}	ForeColor(blueColor);	PenPat(&qd.gray);	for (i=0; i<10; i++) {		r.top = ((short)(i/2))*45+18;		r.bottom = r.top + 34;		r.left = 333+(i%2)*100;		r.right = r.left + 34;		FrameRect(&r);	}	PenPat(&qd.black);	ForeColor(blackColor);	r.top = ((short)(soundSelected/2))*45+18;	r.bottom = r.top + 34;	r.left = 333+(soundSelected%2)*100;	r.right = r.left + 34;	FrameRect(&r);	r.left = 20; r.right = 280;	r.top = 40; r.bottom = 100;	FrameRect(&r);	MoveTo(r.left+1,r.bottom);	LineTo(r.right,r.bottom);	LineTo(r.right,r.top+1);	TextFont(systemFont);	TextSize(12);	sprintf((char*)msg,"Sound Information:");	CtoPstr((char*)msg);	MoveTo(150-StringWidth(msg)/2,60);	DrawString(msg);	if (rob[botSelected].sounds[soundSelected]) {		bringSoundToMemory(botSelected,soundSelected);		if (*(rob[botSelected].sounds[soundSelected]) == NULL)			sprintf((char*)msg,"Error:  Sound Purged");		else {			size = GetHandleSize(rob[botSelected].sounds[soundSelected]);			sprintf((char*)msg,"Size = %ld",size);		}	}	else sprintf((char*)msg,"No Sound Recorded");	CtoPstr((char*)msg);	MoveTo(150-StringWidth(msg)/2,80);	DrawString(msg);	recordingToolsValid[0] = (rob[botSelected].sounds[soundSelected] != NULL);	recordingToolsValid[1] = features.hasSoundIO && features.hasSoundDevice;	for (i=0; i<2; i++) 		if (recordingToolsValid[i]) {			PlotIcon(&recordingToolsRect[i],recordingToolsIcon[i]);		}	MoveTo (170,195); DrawString("\pCompression");	/* Adjust Controls */	if (controlChange) {		controlChange = 0;		for (i=0; i<3; i++)			ShowControl(qualityButtons[i]);	}}void studioRecordSound(void){	long offset,memAvail;	short refNum;	Handle newSnd,theSnd;	OSErr err;	Point pt = {100,100};	if (features.hasSoundDevice && features.hasSoundIO) {		clearChannel();		memAvail = MaxMem(&offset)-10000; /* Save a bit of memory for a good cause */		if (rob[botSelected].sounds[soundSelected]) {			bringSoundToMemory(botSelected,soundSelected);		}		getOldSound();			setVolume(rob[botSelected].vRefNum);				CreateResFile(rob[botSelected].name);		if ((refNum = OpenResFile(rob[botSelected].name)) == -1)			reportMessage ("Error opening robot resources","");		else {			if (memAvail > 40000) memAvail = 40000;			newSnd = NewHandle(memAvail);			checkMemErr("RecordingStudio:studioRecordSound:1");			err = SndRecord(NULL,pt,sndQuality == 0 ? 'best' : sndQuality == 1 ? 							'betr' : 'good',(SndListHandle*)&newSnd);			if (err != noErr && err != userCanceledErr) {				if (err == siInputDeviceErr)					reportMessage("Error recording sound","Is the microphone connected?");				else checkSndErr(err,"RecordingStudio:studioRecordSound");				if (newSnd != NULL) DisposeHandle(newSnd);				checkMemErr("RecordingStudio:studioRecordSound:2");			}			else if (err != userCanceledErr) {				if (rob[botSelected].sounds[soundSelected] != NULL) {					theSnd = GetResource('snd ',SoundID+soundSelected);					RemoveResource(theSnd);					checkResErr("RecordingStudio:studioRecordSound:1");					DisposeHandle(theSnd);					checkMemErr("RecordingStudio:studioRecordSound:3");					DisposeHandle(rob[botSelected].sounds[soundSelected]);					checkMemErr("RecordingStudio:studioRecordSound:4");				}				rob[botSelected].sounds[soundSelected] = newSnd;				if (HandToHand(&newSnd)) SysBeep(1);				checkMemErr ("Recording Studio:studioRecordSound:5");				AddResource(newSnd,'snd ',SoundID+soundSelected,noName);				checkResErr("RecordingStudio:studioRecordSound:2");				SetResAttrs(newSnd,resPurgeable);				ChangedResource(newSnd);				UpdateResFile(refNum);				HPurge(rob[botSelected].sounds[soundSelected]);				EnableItem(myMenus[2],undo_);				modifyFlag = 1;				invalSounds();				adjustSoundMenus();				DisposeHandle(newSnd);				checkMemErr("RecordingStudio:studioRecordSound:5");			}			else {				if (newSnd != NULL) DisposeHandle(newSnd);				checkMemErr("RecordingStudio:studioRecordSound:6");			}		}		CloseResFile (refNum);		restoreVolume();	}}void studioPlaySound(void){	playSound(soundSelected,botSelected);}void clickInRecordingTool(short which){	InvertRect(&recordingToolsRect[which]);	switch (which) {		case 0:  studioPlaySound(); break;		case 1:  studioRecordSound(); break;		default:  SysBeep(1);	}	InvertRect(&recordingToolsRect[which]);}void trackRecordingButton(ControlHandle what){	short i;		if (TrackControl(what,myEvent.where,NULL)) {		for (i=0; i<3; i++) {			if (qualityButtons[i] == what) {				SetControlValue(qualityButtons[i],1);				sndQuality = i;			}			else SetControlValue(qualityButtons[i],0);		}	}}void clickRecording(void){	short hit,i;	Rect r;		hit = soundSelected;	GlobalToLocal(&myEvent.where);	for (i=0; i<2; i++) 		if (PtInRect(myEvent.where,&recordingToolsRect[i]) && recordingToolsValid[i]) 			clickInRecordingTool(i); 	for (i=0; i<5; i++) 		if (myEvent.where.v >i*45+18 && myEvent.where.v < i*45+52) {			if (myEvent.where.h > 333 && myEvent.where.h < 367) hit = i+i;			else if (myEvent.where.h > 433 && myEvent.where.h < 467) hit = i+i+1;		}	if (hit != soundSelected) {		r.top = ((short)(soundSelected/2))*45+18;		r.bottom = r.top + 34;		r.left = 333+(soundSelected%2)*100;		r.right = r.left + 34;		InvalRect(&r);		soundSelected = hit;		invalSounds();				adjustSoundMenus();		DisableItem(myMenus[2],undo_);	}		}void setupRecordingTools(void){	short i;	Rect r;		for (i=0; i<2; i++) {		SetRect(&recordingToolsRect[i],50+i*60,200,82+i*60,232);		recordingToolsIcon[i] = GetIcon(playIcon+i);		MoveHHi(recordingToolsIcon[i]);		HLock(recordingToolsIcon[i]);	}		for (i=0; i<3; i++) {		r.left = 170; r.right = 290;		r.top = 200+15*i; r.bottom = r.top + 15;		qualityButtons[i] = NewControl(myWindow,&r,noName,FALSE,i==sndQuality,0,1,									   radioButProc,radioRefCon);		if (qualityButtons[i] == NULL) 			reportMessage("Error allocating controls","");	}	SetControlTitle(qualityButtons[0],"\pNone");	SetControlTitle(qualityButtons[1],"\p3:1");	SetControlTitle(qualityButtons[2],"\p6:1");}void initRecording(void){	controlChange = 1;	InvalRect (&myWindow->portRect);	DisableItem(myMenus[2],undo_);	undoHandle = NULL;	modifyFlag = 0;	soundSelected = 0;	setupRecordingTools();	checkForSoundInScrap();	adjustSoundMenus();		sndOnQ = gPrefs.soundFlag;	if( !sndOnQ )		doSoundFlag();}void closeRecording(void){	short refNum;	unsigned long dateTime;	long tmp,**aRes;	Handle res1;	short i;	for (i=0; i<2; i++) {		HUnlock(recordingToolsIcon[i]);		HPurge(recordingToolsIcon[i]);	}	for (i=0; i<3; i++) 		if (qualityButtons[i] != NULL) {			(*qualityButtons[i])->contrlRect.bottom = (*qualityButtons[i])->contrlRect.top;			(*qualityButtons[i])->contrlRect.right = (*qualityButtons[i])->contrlRect.left;			DisposeControl(qualityButtons[i]); 		}	if (modifyFlag) {	   	GetDateTime(&dateTime);		setVolume(rob[botSelected].vRefNum);				CreateResFile(rob[botSelected].name);		if ((refNum = OpenResFile(rob[botSelected].name)) == -1)			reportMessage ("Error writing robot resources","");		else {			if ((res1 = GetResource('DATE',recordingDateID)) != NULL) {				RemoveResource(res1);				checkResErr("RecordingStudio:closeRecording:1");				DisposeHandle(res1);			}			aRes = (long**)NewHandle(4);			(*aRes)[0] = dateTime;			AddResource((Handle)aRes,'DATE',recordingDateID,"\pHardware");			checkResErr("RecordingStudio:closeRecording:2");							CloseResFile (refNum);		}		restoreVolume();	}	if (undoHandle != NULL) DisposeHandle(undoHandle);			MaxMem(&tmp);	/* Purge sounds to free up heap space */		if( sndOnQ != gPrefs.soundFlag )		doSoundFlag();}void copySnd(void){	long size;		if (rob[botSelected].sounds[soundSelected] == NULL) SysBeep(1);	else {		bringSoundToMemory(botSelected,soundSelected);		HLock(rob[botSelected].sounds[soundSelected]);		if (ZeroScrap()) reportMessage ("Unable to Zero scrap","");		size = GetHandleSize(rob[botSelected].sounds[soundSelected]);		if (PutScrap(size,'snd ',*rob[botSelected].sounds[soundSelected]) != noErr) SysBeep(1);		HUnlock(rob[botSelected].sounds[soundSelected]);		checkMemErr("RecordingStudio:copySound");		sndInDeskScrap = 1;	}	adjustSoundMenus();}void pasteSnd(Handle pasteSnd){	long offset,result,result2,memAvail;	short refNum;	Handle newSnd,theSnd;	OSErr err;	if ((result = GetScrap(NULL,'snd ',&offset)) >= 0 || pasteSnd != NULL) {		/* Check if space to paste resource */		memAvail = MaxMem(&offset);		if (memAvail < 2.2*result) {			reportMessage("Memory Too Low","Can't Paste sound");		}		else {			if (rob[botSelected].sounds[soundSelected]) 				bringSoundToMemory(botSelected,soundSelected);			getOldSound();			setVolume(rob[botSelected].vRefNum);						CreateResFile(rob[botSelected].name);			if ((refNum = OpenResFile(rob[botSelected].name)) == -1)				reportMessage ("Error opening robot resources","");			else {				if (rob[botSelected].sounds[soundSelected] != NULL) {					theSnd = GetResource('snd ',SoundID+soundSelected);					RemoveResource(theSnd);					checkResErr("RecordingStudio:pasteSound:1");					DisposeHandle(theSnd);					checkMemErr("RecordingStudio:pasteSound:1");					DisposeHandle(rob[botSelected].sounds[soundSelected]);					checkMemErr("RecordingStudio:pasteSound:2");					rob[botSelected].sounds[soundSelected] = NULL;				}				if (pasteSnd == NULL) {					rob[botSelected].sounds[soundSelected] = NewHandle(result);					checkMemErr("RecordingStudio:pasteSound:3");					result2 = GetScrap(rob[botSelected].sounds[soundSelected],'snd ',&offset);				}				else {					rob[botSelected].sounds[soundSelected] = pasteSnd;					err = HandToHand(&rob[botSelected].sounds[soundSelected]);					if (err) SysBeep(1);				}				sndInDeskScrap = 1;				newSnd = rob[botSelected].sounds[soundSelected];				if(HandToHand(&newSnd)) SysBeep(1);				AddResource(newSnd,'snd ',SoundID+soundSelected,noName);				checkResErr("RecordingStudio:pasteSound:2");				SetResAttrs(newSnd,resPurgeable);				ChangedResource(newSnd);				UpdateResFile(refNum);				HPurge(rob[botSelected].sounds[soundSelected]);				EnableItem(myMenus[2],undo_);			}			CloseResFile (refNum);			restoreVolume();			invalSounds();			modifyFlag = 1;		}	}	else sndInDeskScrap = 0;	adjustSoundMenus();}void clearSnd(void){	short refNum;	Handle theSnd;	clearChannel();	if (rob[botSelected].sounds[soundSelected] == NULL) SysBeep(1);	else {		bringSoundToMemory(botSelected,soundSelected);		getOldSound();		/* Release Sound Resource */	 	setVolume(rob[botSelected].vRefNum);				CreateResFile(rob[botSelected].name);		if ((refNum = OpenResFile(rob[botSelected].name)) == -1)			reportMessage ("Error opening robot resources","");		else {			theSnd = GetResource('snd ',SoundID+soundSelected);			RemoveResource(theSnd);			checkResErr("RecordingStudio:clearSnd");			DisposeHandle(theSnd);			checkMemErr("RecordingStudio:clearSound:1");			DisposeHandle(rob[botSelected].sounds[soundSelected]);			checkMemErr("RecordingStudio:clearSound:2");			rob[botSelected].sounds[soundSelected] = NULL;		}		invalSounds();		dimMenus();		modifyFlag = 1;		CloseResFile (refNum);		restoreVolume();		EnableItem(myMenus[2],undo_);	}	adjustSoundMenus();}void cutSnd(void){	copySnd();	clearSnd();}void undoSnd(void){	Handle tmp;		if (undoHandle == NULL) clearSnd();	else {		tmp = undoHandle;		HandToHand(&tmp);		pasteSnd(tmp);		DisposeHandle(tmp);	}}