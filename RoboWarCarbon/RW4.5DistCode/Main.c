/* Main.c *//* 	Written 12/16/89 by David Harris & Lucas Dixon	(c) 1989 Lucas Dixon & David Harris		This is the main file for RoboWar.  It handles	the user interface and some basic aspects of the	game.		Documents created are of creator 'RWAR' and type 'RobW'.	Preferences are of creator 'RWAR' and type 'RobP'	Application is of creator 'RWAR' and type 'APPL'	Application signature is RWAR*///-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=/* #includes *///-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=#include <Carbon/Carbon.h>#include "robotypes.h"/* Globals */MenuHandle			myMenus[kNumOfMenus];			/* Handles to program's menus */										// 0 = 	Apple	// 5 = 										// 1 = 			// 6 = 										// 2 = 			// 7 = 											// 3 = 			// 8 = 	Help											// 4 = 			short				gHelpMenuItem;WindowPtr 			myWindow;			/* The program's window */EventRecord			myEvent;			/* The program's event record */TEHandle			myText;				/* Drafting Board text */ //---x//WEReference			myWText;			// WASTE Text for drafting boardDialogPtr			titleDialog;		/* Title screen */CursHandle			editCursor;			/* IBeam cursor for Drafting Board */CursHandle			watchCurs;			/* Watch cursor for Assembly Line */CursHandle			crossCurs;			/* Crosshair cursor for Icon Editor */GWorldPtr			bulletGW;			//Bullet GWorlds...GWorldPtr			hellBoreGW;GWorldPtr			mineGW;GWorldPtr			newMineGW;GWorldPtr			droneGW[8];GenericIcon			botGW[maxBots][2];										/* Default bit image of a robot */										RgnHandle			explosionMasks[8];	/* Section of exploding robot to display */double				sine[360];			/* Sine functions for each degree */Str255				title;				/* Title of current mode */ControlHandle		myScrollBar;		/* Drafting Board's scroll bars */ControlHandle		goButton;			/* Debugger go button */ControlHandle		pauseButton;		/* Debugger pause button */ControlHandle		stepButton;			/* Debugger step button */ControlHandle		chrononButton;		/* Debugger chronon button */ControlHandle		battleButton;		/* Single battle in Arena */ControlHandle 		toolsControlHdl;	/* Tools PopUpMenu in IconFactory */	//--- 19 apr 97ControlActionUPP	scrollUPP;			/* Scrolling procedure for Drafting Board */UserItemUPP			hiliteButtonUPP;	/* Initialized for util.c *///THPrint				printRecord;		/* Printing record */macFeatures			features;			/* The capabilities of the host Macintosh *///Handle				undoText;			/* Text for Undo Command *///short				undoState;			/* Info concerning Undo *///long				undoStart;			/* Start of selection in undo *///long				undoEnd;			/* End of selection in undo */Str255				noName; 			/* The empty string */void 				(*updateFun[7])();	/* Pointers to update functions */void				(*clickFun[7])();	/* Pointers to click in window functions *///char				registered[80];		/* Name of registered user *///long				code;				/* Code number of user */short				rosterChanged;		/* Invalidate old history */short				controlChange;	 	/* 1 = Show mode's controls */short				mode;				/* Program's current mode */short				numBots;			/* Number of bots to battle */short				botSelected;		/* Which bot is selected, maxBots = None */short				quitFlag;			/* 1 = Quit Program */short				isBattle;			/* 1 = Battle in progress */short				isTournament;		/* 1 = Tournament in progress *///short				displayCode;		/* 1 = Draw entire field, 2 = draw just stats, 3 = nothing *///short				soundFlag;			/* 1 = Play sounds in game */short				oldSoundFlag;		/* Keep old flag while game is in background *///short				battleSpeed;		/* 0 = Fast, 4 = Slowest */short				modifyFlag;			/* Has a change been made in one of the editors */short				useDebugger;		/* Use the debugger? (MaxBot = no debugger) */short				pausedFlag;			/* 1 = paused in debugger */short				stepFlag;			/* 1 = step forward in debugger */short				chrononFlag;		/* Do one chronon in the debugger */short				aggressiveFlag;		/* Aggressive scoring on tournaments */short				officialFlag;		/* Official rules on tournaments */short				lowBitMapMemoryFlag;/* Is memory too low for full colors */unsigned short 		lastRandSeed;		/* Retain random seed to repeat battles */Str255				findStr;			/* String of text to find */Str255				replaceStr;			/* String with replacement text */robot				rob[maxBots];		/* The robots */shot				*shots;				/* Head of list of shots */Ptr					safeMem;prefStruct			gPrefs;				#if __POWERPC__	/*extern*/	QDGlobals	qd;					/* To make PowerPC happy */#endif/* Prototypes */void initMac(void);void initProgram(void);void doTitleDialog(void);void universalUpdate(void);void universalClick(void);void clearOldMark(void);void resetView(void);void changeMode(short newMode);void menuEvent(long code);void dragEvent(WindowPtr whichWindow);void updateMenus(void);void mouseEvent(void);void keyEvent(void);void activateEvent(void);void osEvent(void);void activateRoboWar(void);void deactivateRoboWar(void);void updateEvent(void);void diskEvent(void);void mainEventLoop(void);void closeProgram(void);void main(void);/* In DraftingBoard.c */extern void updateDrafting();							extern void clickDrafting();extern pascal void scrollProc(ControlHandle,short);extern void textKey(char c, short modifiers);extern void cutText(void);extern void copyText(void);extern void pasteText(void);extern void clearText(void);extern void selectAll(void);extern void undoTyping(void);extern void findText(void);extern void replaceFind(void);extern void doFind(void);extern void doReplace(void);extern void showSelected(void);extern void draftingSpecial(void);/* in DraftingBoard.c */extern void printRobotCode(TPPrPort);extern void updateScrolledText(void);extern void saveRobot(void);extern void readRobotText(void);extern void CloseDraftingBoard(void);extern void InitDraftingBoard(void);extern void GotoLabel( short theItem );extern void UpdateFromPrefsChange(void);/* in HardwareStore.c */extern void updateHardware();							extern void clickHardware();extern void initHardware();extern void closeHardware(void);extern void trackRadioButton(ControlHandle what);extern void trackCheckBox(ControlHandle what);/* in ArenaControl.c */extern void updateArena();							extern void clickCamp();extern void initArena();extern void closeArena(void);extern void battle(short repeatFlag);/* In IconFactory.c */extern void updateIcon();							extern void clickIcon();//extern void trackIconButton(ControlHandle); //--- 19 apr 97 --- This is unused...extern void initIcons();extern void closeIcons(void);extern void copyIcon(void);extern void pasteIcon(void);extern void clearIcon(void);extern void cutIcon(void);extern void undoIcon(void);extern void IconToScrap(void);extern void iconSpecial(void);extern void doToolSelect(Point where);	//--- 19 apr 97/* In RecordingStudio.c */extern void trackRecordingButton(ControlHandle what);extern void updateRecording();							extern void clickRecording();extern void initRecording();extern void closeRecording(void);extern void copySnd(void);extern void pasteSnd(Handle pasteSnd);extern void clearSnd(void);extern void cutSnd(void);extern void undoSnd(void);extern void checkForSoundInScrap(void);extern void adjustSoundMenus(void);/* in File.c */extern short openRobot();extern void newRobot(void);extern void duplicateRobot(void);extern void saveAsRobot(void);extern void closeRobot(void);extern void pageSetup(void);extern void print(void);/* in About.c*/extern void aboutBox(void);/* in Util.c */extern Boolean sameBot(short);extern pascal void hiliteButtonProc(WindowPtr,short);extern void drawRobot(short,short,short,short,short,RgnHandle,short);extern void fatalError(short code);extern void initSounds(void);extern void getFeatures(void);extern void setTitle(char *what);extern void checkMemErr(char *proc);extern void reportMessage(char *message1,char *message2);extern void clearChannel(void);/* in Tournament.c */extern void doTournament(void);/* in Camp.c */extern void adjustHilite(char);extern void setAlone(void);extern void setTeam1(void);extern void setTeam2(void);extern void setTeam3(void);/* in AppleEvents.c */extern void installAppleEventHandlers(void);extern void highLevelEvent(EventRecord*);/* in ArenaControl.c */extern void createBitMaps(void);extern void loadRobots(void);extern void setArenaFunctions(void);extern void doSoundFlag(void);extern void doSetSpeed(short speed);extern void doSetDisplay(short display);extern void doSetMaxPoints(void);/* in Registration.c */extern void readPrefs(void);extern void writePrefs(void);extern void drawRegistration(void);extern void doRegistration(void);/* in Password.c */extern short getPassword(char*);extern void doPassword(void);// - In PrefsDialog.cextern void DoPrefsDialog(void);// - In RulesDlog.cextern void DoRulesDialog(void);/* in Help.c */extern void 			helpDialog(void);/* in AssemblyLine.c */extern void assembleRobot(short errorInstruction);/* in Debugger.c */void doDebugger(void);/* in Tournament.c */void setupTournament(void);/* in History.c */void showHistory(void);void clearHistory(void);/* Code *//**** Initialization Routines ****/// --- Init Toolbox, Menu's, Window, Buttons.void initMac(void){	short i;		//reportMessage(" Initialising RoboWar - InitGraf","initMac:0" );		// --- Init ToolBox		InitGraf(&qd.thePort);	//reportMessage("InitFonts","initMac:0" );	InitFonts();	//reportMessage("InitWindows","initMac:0" );	InitWindows();	//reportMessage("InitMenus","initMac:0" );	InitMenus();	//--- tho we use WASTE for the drafting board, dialogs, etc all use TextEdit so don't remove this!	//reportMessage("TEInit","initMac:0" );	TEInit();	//reportMessage("InitDialogs","initMac:0" );	InitDialogs(NULL);	//reportMessage("InitCursor","initMac:0" );	InitCursor();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	MaxApplZone();		//reportMessage(" Initialising RoboWar Menu's","initMac:0" );	// --- Init Menu's	noName[0] = 0;		for (i=0; i<5; i++) {		myMenus[i] = GetMenu(appleMenuID+i);		if (myMenus[i] != NULL)			InsertMenu(myMenus[i],0);		else fatalError(1);	}	myMenus[5] = GetMenu(speedMenuID);	if (myMenus[5] != NULL)		InsertMenu(myMenus[5],-1);	else fatalError(1);	myMenus[6] = GetMenu(displayMenuID);	if (myMenus[6] != NULL)		InsertMenu(myMenus[6],-1);	else fatalError(1);	myMenus[7] = GetMenu(historyMenuID);	if (myMenus[7] != NULL)		InsertMenu(myMenus[7],-1);	else fatalError(1);	// add the apple menu...	AppendResMenu(myMenus[0],'DRVR');		//reportMessage(" Initialising RoboWar Help Menu's","initMac:1" );		// --- if this mac has a help menu, put RoboWar help in that menu,	if( noErr == HMGetHelpMenuHandle( &myMenus[8]) )	{		gHelpMenuItem = CountMenuItems(myMenus[8]);		InsertMenuItem( myMenus[8], "\pRoboWar Help...", gHelpMenuItem );		// Set the help menu item to itself instead of the 		// previous menu (the old menu count.		gHelpMenuItem++; 	}		DrawMenuBar();		//reportMessage(" Initialising RoboWar Sound","initMac:2" );	initSounds();		//reportMessage(" Initialising RoboWar window","initMac:2.1" );	//--- 19 apr 97 --- a Color Window is needed to used color icons.	myWindow = GetNewCWindow(WindowID,NULL,(WindowPtr)-1L);		if (myWindow != NULL)		SetPort(myWindow);	else fatalError(2);		//reportMessage(" Initialising RoboWar controls","initMac:3" );	goButton = GetNewControl(GoID,myWindow);	if (goButton == NULL)		fatalError(4);		pauseButton = GetNewControl(PauseID,myWindow);	if (pauseButton == NULL)		fatalError(4);		stepButton = GetNewControl(StepID,myWindow);	if (stepButton == NULL)		fatalError(4);		chrononButton = GetNewControl(ChrononID,myWindow);	if (chrononButton == NULL)		fatalError(4);		battleButton = GetNewControl(BattleID,myWindow);	if (battleButton == NULL)		fatalError(4);	myScrollBar = GetNewControl(ScrollID,myWindow);	if (myScrollBar == NULL)		fatalError(4);		//--- 19 apr 97 --- We get the control handle for the tools pop up menu.	toolsControlHdl = GetNewControl(toolsMenuID,myWindow);	if(toolsControlHdl == NULL)		fatalError(4);		scrollUPP = NewControlActionProc(&scrollProc);	hiliteButtonUPP = NewUserItemProc(&hiliteButtonProc);	//reportMessage(" Initialising RoboWar Cursors","initMac:4" );	editCursor = GetCursor(iBeamCursor);	if (editCursor == NULL) **editCursor = qd.arrow;  /* Fake if not available */	watchCurs = GetCursor(watchCursor);	if (watchCurs == NULL) **watchCurs = qd.arrow;	crossCurs = GetCursor (crossCursor);	if (crossCurs == NULL) **crossCurs = qd.arrow;}// --- Set up the program datavoid initProgram(void){		//reportMessage(" Initialising RoboWar Program","initProgram:0" );	ShowWindow(myWindow);	getFeatures();		if( features.hasFSSpecCalls == 0 )	{		reportMessage(	"Sorry but RoboWar needs to be able to use hasFSSpecCalls", 						"your mac doesn't have this :( \n main:initProgram:1");		ExitToShell();						// - Can't run without FileSpec calls	}		if (features.hasAppleEventManager) 		installAppleEventHandlers();	if (LoadScrap()) SysBeep(1);		//reportMessage(" Reading RW Prefs","initProgram:1" );	readPrefs();		// --- WASTE init	InitTSMAwareApplication();// - Make prog use text services manager	WEInstallTSMHandlers();	// --- don't care if not TSM aware	if( WEInstallTSMHandlers() != noErr )	// - Setup Waste	{			reportMessage("Couldn't Setup WASTE Text handling", "main:initProgram:1");		ExitToShell();						// - Can't run without waste	}	//if( features.hasDragAndDrop )	//	InstallDragHandlers();				// - ignore if fail, drag and drop isn't essential	//InitSmartScrollAwareApplication();		// - Lets have active scrolling		//reportMessage(" Setting robowar base data","initProgram:2" );	numBots = 0;	quitFlag = 0;	shots = NULL;	botSelected = maxBots;	useDebugger = maxBots;	controlChange = 0;	rosterChanged = 1;	findStr[0] = 0;	replaceStr[0] = 0;	mode = arena;	aggressiveFlag = TRUE;	officialFlag = TRUE;	lowBitMapMemoryFlag = FALSE;	lastRandSeed = (unsigned short)TickCount();	//reportMessage("Main RW setup","initProgram:3" );	createBitMaps();	setArenaFunctions();	//reportMessage("Main RW setup:2","initProgram:0" );	loadRobots();	initArena();	setTitle("");	SetItemMark(myMenus[3],arena_,checkMark);	DisableItem(myMenus[2],selectAll_);	DisableItem(myMenus[2],find_);	DisableItem(myMenus[2],replace_);	DisableItem(myMenus[2],findNext_);	DisableItem(myMenus[2],replaceFind_);	updateFun[1] = updateDrafting;	updateFun[2] = updateHardware;	updateFun[4] = updateRecording;	updateFun[5] = updateArena;	updateFun[6] = updateIcon;	clickFun[1] = clickDrafting;	clickFun[2] = clickHardware;	clickFun[4] = clickRecording;	clickFun[5] = clickCamp;	clickFun[6] = clickIcon;	//reportMessage("doTitleDialog","initProgram:0" );	doTitleDialog();}void doTitleDialog(void){	short itemHit,i;		titleDialog = GetNewDialog(TitleDlogID,NULL,(WindowPtr)-1);	DrawDialog(titleDialog); 	SetPort(titleDialog);/*	drawRegistration(); */	// --- Setup sine global (used as a constant)	for (i=0; i<360; i++) {		sine[i] = sin((double)(90-i)*0.01745329252); /* ¹/180 */		//sine[i+1] = sine[i]; /* Approximation for fast computation */		//sine[i+2] = sine[i];	}	do {		ModalDialog(NULL,&itemHit);	} while (!itemHit);	SetPort(myWindow);	DisposeDialog(titleDialog); }/**** Mode-sensitive Routines ****/void universalUpdate(void){		short i;		/* Draw box in corner */	PenPat(&qd.black);	ForeColor(blackColor);	PenSize(2,2);	MoveTo (300,300);	LineTo (300,250);	LineTo(500,250);	TextFont (systemFont);	TextSize (12); 	MoveTo (300,250);	LineTo (300,0);	MoveTo (400-StringWidth(title)/2,15);	TextFace(bold+underline);	DrawString (title);	TextFace(0);	PenSize(1,1);		/* Draw Robot */	if (botSelected != maxBots) {		i = 0;				drawRobot(-2,321,270,90,i,NULL,rob[botSelected].turretType);				MoveTo (305,296);		DrawString (rob[botSelected].name);	}	else {		MoveTo (305,265); DrawString ("\p    No");		MoveTo (305,280); DrawString ("\p  Robot");		MoveTo (305,295); DrawString ("\pSelected");	}	TextFont (kFontIDMonaco);	TextSize (9); 		/* Draw Controls */	DrawControls (myWindow);}void universalClick(void){	ControlHandle whichControl;	short part;		GlobalToLocal(&myEvent.where);	if ((part = FindControl(myEvent.where,myWindow,&whichControl))) {		if (whichControl == battleButton) {			if (TrackControl(whichControl,myEvent.where,NULL)) {				if (isBattle) {					isBattle = 0;					isTournament = 0;				} 				else battle(myEvent.modifiers & optionKey);			}		}		else if (whichControl == goButton) {			if (TrackControl(whichControl,myEvent.where,NULL)) {				pausedFlag = 0;				HiliteControl(goButton,255);				HiliteControl(pauseButton,0);				HiliteControl(stepButton,255);				HiliteControl(chrononButton,255);			}		}		else if (whichControl == pauseButton) {			if (TrackControl(whichControl,myEvent.where,NULL)) {				pausedFlag = 1;				HiliteControl(goButton,0);				HiliteControl(pauseButton,255);				HiliteControl(stepButton,0);				HiliteControl(chrononButton,0);			}		}		else if (whichControl == chrononButton) {			if (TrackControl(whichControl,myEvent.where,NULL)) {				chrononFlag = 1;			}		}		else if (whichControl == stepButton) {			if (TrackControl(whichControl,myEvent.where,NULL)) {				stepFlag = 1;			}		}		else if (whichControl == myScrollBar) {			if (part == kControlIndicatorPart) {				TrackControl (whichControl,myEvent.where,NULL);				updateScrolledText();			}			else				TrackControl(whichControl,myEvent.where,scrollUPP);		}		else if ((*whichControl)->contrlRfCon == radioRefCon) { /* Radio Button */			if (mode == hardwareStore) trackRadioButton(whichControl);			else if (mode == recordingStudio) trackRecordingButton(whichControl);		}		else if ((*whichControl)->contrlRfCon == checkRefCon) /* Check Box */			trackCheckBox(whichControl);		//--- 19 apr 97 --- if the user clicks on the toolsMenu (in Icon Factory) then		//					do select tool.		else if (whichControl == toolsControlHdl)			doToolSelect(myEvent.where);	}	LocalToGlobal(&myEvent.where);}void clearOldMark(void){	switch (mode) {		case draftingBoard: SetItemMark(myMenus[3],draftingBoard_,noMark); break;		case hardwareStore: SetItemMark(myMenus[3],hardwareStore_,noMark); break;		case iconFactory: SetItemMark(myMenus[3],iconFactory_,noMark); break;		case recordingStudio: SetItemMark(myMenus[3],recordingStudio_,noMark); break;		case arena:	SetItemMark(myMenus[3],arena_,noMark); break;	}}void resetView(void){	if (mode == arena) {		closeArena();		DisableItem(myMenus[4],0);		DrawMenuBar();	}	else if (mode == hardwareStore) closeHardware();	else if (mode == iconFactory) closeIcons();	else if (mode == recordingStudio) closeRecording();	else if (mode == draftingBoard) {		if (modifyFlag) saveRobot();		//TEDispose (myText); //---r		//DisposeHandle(undoText);		CloseDraftingBoard();		checkMemErr("Main:resetView");	}			clearOldMark();	DisableItem(myMenus[2],undo_);	DisableItem(myMenus[2],cut_);	DisableItem(myMenus[2],copy_);	DisableItem(myMenus[2],paste_);	DisableItem(myMenus[2],clear_);	DisableItem(myMenus[2],selectAll_);	DisableItem(myMenus[2],find_);	DisableItem(myMenus[2],replace_);	DisableItem(myMenus[2],findNext_);	DisableItem(myMenus[2],replaceFind_);	SetCursor (&qd.arrow);	HideControl (myScrollBar);	HideControl (battleButton);	HideControl (goButton);	HideControl (pauseButton);	HideControl (stepButton);	HideControl (chrononButton);}void changeMode(short newMode){	short 		ok,i;	Rect		r;	//LongRect	wasteSizeRect, destRect;	Rect	wasteSizeRect, destRect;	UInt32		weTextUsed;	if (!rob[botSelected].passwordEntered && newMode != arena_) {		ok = getPassword(rob[botSelected].password);		if (ok) {			for (i=0; i < numBots; i++)				if (sameBot(i)) 					rob[i].passwordEntered = 1;		}		else {			reportMessage ("Sorry, incorrect password.","");			return;		}	}	if (newMode == draftingBoard_ && mode != draftingBoard) {		resetView();		modifyFlag = 0;		mode = draftingBoard;		r.top = 1; r.bottom = 298;		r.left = 1; r.right = 282;		TextFont (kFontIDMonaco);		TextSize (9);				//---r myText = TENew(&r,&r);		WERectToLongRect ( &r, &wasteSizeRect) ;		//r.top += 1;		//r.bottom += 1;		weTextUsed = (gPrefs.syntaxColoringQ)? 0 : weDoMonoStyled;		weTextUsed += weDoAutoScroll +				weDoOutlineHilite +				weDoUndo +				//weDoIntCutAndPaste +				//weDoDragAndDrop +				weDoUseTempMem +				weDoDrawOffscreen;						WERectToLongRect ( &r, &destRect) ;		if( WENew(  &destRect, 					&wasteSizeRect,						weTextUsed,					&myWText) != noErr)		{			reportMessage("Couldn't make new WEText area", "main:changeMode:1");			ExitToShell();	//---x		}		if( WESetInfo ( weRefCon, &myWindow, myWText ) != noErr )		{			reportMessage("Problem with seting WATSTE info", "main:initProgram:2");			ExitToShell();	//---x		}				readRobotText();				//---x TEAutoView(TRUE,myText);		WEActivate( myWText );		//---r TEActivate(myText);				InvalRect (&myWindow->portRect);		setTitle("Drafting Board");		EnableItem(myMenus[2],undo_);		EnableItem(myMenus[2],cut_);		EnableItem(myMenus[2],copy_);		EnableItem(myMenus[2],paste_);		EnableItem(myMenus[2],clear_);		EnableItem(myMenus[2],selectAll_);		EnableItem(myMenus[2],find_);		EnableItem(myMenus[2],replace_);		if (findStr[0])			EnableItem(myMenus[2],findNext_);		if (replaceStr[0])			EnableItem(myMenus[2],replaceFind_);		controlChange = 1;		SetItemMark(myMenus[3],draftingBoard_,checkMark);		InitDraftingBoard();	}	else if (newMode == hardwareStore_ && mode != hardwareStore) {		clearOldMark();		resetView();		mode = hardwareStore;		initHardware();		setTitle("Hardware Store");		SetItemMark(myMenus[3],hardwareStore_,checkMark);	}	else if (newMode == arena_ && mode != arena) {		resetView();		mode = arena;		loadRobots();		initArena();		setTitle("");		EnableItem(myMenus[4],0);		DrawMenuBar();		SetItemMark(myMenus[3],arena_,checkMark);	}			else if (newMode == iconFactory_ && mode != iconFactory) {		resetView();		mode = iconFactory;		EnableItem(myMenus[2],undo_);		EnableItem(myMenus[2],cut_);		EnableItem(myMenus[2],copy_);		EnableItem(myMenus[2],paste_);		EnableItem(myMenus[2],clear_);		initIcons(); 		setTitle("Icon Factory");		SetItemMark(myMenus[3],iconFactory_,checkMark);	}			else if (newMode == recordingStudio_ && mode != recordingStudio) {		resetView();		mode = recordingStudio;		EnableItem(myMenus[2],undo_);		EnableItem(myMenus[2],cut_);		EnableItem(myMenus[2],copy_);		EnableItem(myMenus[2],paste_);		EnableItem(myMenus[2],clear_);		initRecording(); 		setTitle("Recording Studio");		SetItemMark(myMenus[3],recordingStudio_,checkMark);	}}/**** Event Handling ****/void menuEvent(long code){	short theMenu,theItem;	Str255 name;	Rect r;		theMenu = HiWord(code);	theItem = LoWord(code);		switch(theMenu) {		case appleMenuID: if (theItem == about_) aboutBox();					 else if (theItem == help_) helpDialog();					 else {					 	GetMenuItemText(myMenus[0],theItem,name);					 	OpenDeskAcc(name);					 	SetPort(myWindow);					 }					 break;		case kHMHelpMenuID:   			if( theItem == gHelpMenuItem )   				helpDialog();   			break;		case fileMenuID: switch(theItem) {							case new_: newRobot(); break;							case open_: openRobot(); break;							case duplicate_: duplicateRobot(); break;							case saveAs_: saveAsRobot(); break;							case close_: closeRobot(); break;							case pageSetup_: pageSetup(); break;							case print_: print(); break;							/* case register_: doRegistration(); break; */							case quit_: quitFlag = 1;										isBattle = 0;										isTournament = 0;										break;						 }						 break;		case editMenuID: if (!SystemEdit(theItem-1)) {							if (mode == draftingBoard) {							 switch(theItem) {								case cut_: cutText(); break;								case copy_: copyText(); break;								case paste_: pasteText(); break;								case clear_: clearText(); break;								case undo_: undoTyping(); break;								case selectAll_: selectAll(); break;								case find_: doFind(); break;								case findNext_: findText(); break;								case replace_: doReplace(); break;								case replaceFind_: replaceFind(); break;							 }							}							else if (mode == iconFactory) {								switch (theItem) {									case cut_: cutIcon(); break;									case copy_: copyIcon(); break;									case paste_: pasteIcon(); break;									case clear_: clearIcon(); break;									case undo_: undoIcon(); break;								}							}							else if (mode == recordingStudio) {								switch (theItem) {									case cut_: cutSnd(); break;									case copy_: copySnd(); break;									case paste_: pasteSnd(NULL); break;									case clear_: clearSnd(); break;									case undo_: undoSnd(); break;								}							}														 }						 if (mode == draftingBoard) {						 	showSelected();						 	r.top = 45; r.bottom = 55;							r.left = 420; r.right = 490;							InvalRect(&r);						 }						 if( theItem == preferences_ )						 {						 	DoPrefsDialog();						 	if (mode == draftingBoard)						 		UpdateFromPrefsChange();						 }						 if( theItem == rules_ )						 	DoRulesDialog();   					     break;   					        		case viewMenuID: switch(theItem) {   							case arena_:   							case draftingBoard_:   							case hardwareStore_:   							case iconFactory_:   							case recordingStudio_:   								changeMode(theItem); break;   							case compile_: assembleRobot(-1); break;   							case setPassword_: doPassword(); break;  						}    						break;   		case arenaMenuID: switch(theItem) {   							case teamNone_: setAlone(); break;   							case teamOne_: setTeam1(); break;   							case teamTwo_: setTeam2(); break;   							case teamThree_: setTeam3(); break;   							case debugger_: doDebugger(); break;   							case sound_: doSoundFlag(); break;   							case setMaxPoints_: doSetMaxPoints(); break;   							case automate_: setupTournament(); break;   						}   						break;   		case speedMenuID: doSetSpeed(theItem); break;   		case displayMenuID:  doSetDisplay(theItem); break;   		case historyMenuID:	 switch (theItem) {   							   case showHistory_: showHistory(); break;   							   case clearHistory_: clearHistory(); break;   							 }   							 break;   		case 3001: // Label Menu			GotoLabel( theItem );   			break;	}	HiliteMenu(0);}void dragEvent(WindowPtr whichWindow){	Rect dragRect;		dragRect.left = 4;	dragRect.right = qd.screenBits.bounds.right-4;	dragRect.top = 24;	dragRect.bottom = qd.screenBits.bounds.bottom-4;	DragWindow(whichWindow,myEvent.where,&dragRect);}void updateMenus(void){	DisableItem (myMenus[1],new_);	DisableItem (myMenus[1],open_);	DisableItem (myMenus[1],duplicate_);	DisableItem (myMenus[1],saveAs_);	DisableItem (myMenus[1],close_);	DisableItem (myMenus[1],print_);	DisableItem (myMenus[3],draftingBoard_);	DisableItem (myMenus[3],hardwareStore_);	DisableItem (myMenus[3],iconFactory_);	DisableItem (myMenus[3],recordingStudio_);	DisableItem (myMenus[3],compile_);	DisableItem (myMenus[3],setPassword_);	DisableItem (myMenus[4],teamNone_);	DisableItem (myMenus[4],teamOne_);	DisableItem (myMenus[4],teamTwo_);	DisableItem (myMenus[4],teamThree_);	DisableItem (myMenus[4],automate_);	if (botSelected < numBots) {		if (!isBattle) {			EnableItem (myMenus[3],draftingBoard_);			EnableItem (myMenus[3],hardwareStore_);			EnableItem (myMenus[3],iconFactory_);			EnableItem (myMenus[3],recordingStudio_);			EnableItem (myMenus[3],setPassword_);		}	}	if (mode == arena) {		if (!isBattle) {			EnableItem(myMenus[4],automate_);			if (numBots < maxBots) {				EnableItem (myMenus[1],new_);				EnableItem (myMenus[1],open_);			}			if (botSelected < numBots) {				EnableItem (myMenus[1],saveAs_);				EnableItem (myMenus[1],close_);				EnableItem (myMenus[4],teamNone_);				EnableItem (myMenus[4],teamOne_);				EnableItem (myMenus[4],teamTwo_);				EnableItem (myMenus[4],teamThree_);				if (numBots < maxBots)					EnableItem (myMenus[1],duplicate_);			}		}	}	if (mode == draftingBoard) {		//EnableItem (myMenus[1],print_);		EnableItem (myMenus[3],compile_);	}	if (rosterChanged) {		DisableItem (myMenus[4],historyMenu_);		DisableItem (myMenus[7],showHistory_);		DisableItem (myMenus[7],clearHistory_);	}	else {		EnableItem (myMenus[4],historyMenu_);		EnableItem (myMenus[7],showHistory_);		EnableItem (myMenus[7],clearHistory_);	}}void mouseEvent(void){	WindowPtr whichWindow;			switch(FindWindow(myEvent.where,&whichWindow)) {		case inMenuBar: {						updateMenus();						menuEvent(MenuSelect(myEvent.where));						} break;		case inSysWindow: SystemClick(&myEvent,whichWindow); break;		case inContent: if (whichWindow != FrontWindow()) SelectWindow(whichWindow);						else {							universalClick();							(*clickFun[mode])();						}						break;		case inDrag: dragEvent(whichWindow); break;	}}void keyEvent(void){	short 	c;	long 	selection;	c = (myEvent.message & charCodeMask);	if (myEvent.modifiers & cmdKey) {		if (isalpha(c) && c < 'a') 			c += 'a'-'A';		if ( (c == '\0b' || c == '\0º') && (mode == arena) && (!isBattle) && (numBots > 0) ) 			battle(myEvent.modifiers & optionKey);					else if (c == 'h' && mode == arena && isBattle) {			isBattle = 0;			isTournament = 0;		}		else {			updateMenus();			if (c == '?' || c == '/') 				selection = ((long)appleMenuID << 16) + help_;			else selection = MenuKey(c);			menuEvent(selection);		}	}	else if (mode == draftingBoard)		//WEKey( c, myEvent.modifiers, myWText );		textKey(c, myEvent.modifiers);	else if (mode == arena)		adjustHilite(c);}void activateEvent(void){	if (myEvent.modifiers & activeFlag) activateRoboWar();	else deactivateRoboWar();}void osEvent(void){	if (myEvent.message & 0x01000000 ) {	/* suspend or resume */		if ( myEvent.message & 0x00000001 )	/* resume evt */			activateRoboWar(); 				/* resume means activate */		else			deactivateRoboWar( ); 			/* suspend = deactivate */	}}void activateRoboWar(void){	clearChannel();	gPrefs.soundFlag = oldSoundFlag;	if (mode == draftingBoard) {		WEActivate( myWText );		//---r TEActivate(myText);		EnableItem(myMenus[2],undo_);		EnableItem(myMenus[2],cut_);		EnableItem(myMenus[2],copy_);		EnableItem(myMenus[2],paste_);		EnableItem(myMenus[2],clear_);		EnableItem(myMenus[2],selectAll_);		EnableItem(myMenus[2],find_);		EnableItem(myMenus[2],replace_);		if (findStr[0])			EnableItem(myMenus[2],findNext_);		if (replaceStr[0] && findStr[0])			EnableItem(myMenus[2],replaceFind_);	}	else if (mode == iconFactory) {		EnableItem(myMenus[2],undo_);		EnableItem(myMenus[2],cut_);		EnableItem(myMenus[2],copy_);		EnableItem(myMenus[2],paste_);		EnableItem(myMenus[2],clear_);	}	else if (mode == recordingStudio) {		checkForSoundInScrap();		adjustSoundMenus();	}	else {		DisableItem(myMenus[2],undo_);		DisableItem(myMenus[2],cut_);		DisableItem(myMenus[2],copy_);		DisableItem(myMenus[2],paste_);		DisableItem(myMenus[2],clear_);		DisableItem(myMenus[2],selectAll_);		DisableItem(myMenus[2],find_);		DisableItem(myMenus[2],replace_);		DisableItem(myMenus[2],findNext_);		DisableItem(myMenus[2],replaceFind_);	}	if (LoadScrap()) SysBeep(1);	//TEFromScrap();	SetCursor (&qd.arrow);}void deactivateRoboWar(void){	clearChannel();	oldSoundFlag = gPrefs.soundFlag; gPrefs.soundFlag = 0;	if (mode == draftingBoard) {		WEDeactivate(myWText);		//---r TEDeactivate(myText);		DisableItem(myMenus[2],selectAll_);		DisableItem(myMenus[2],find_);		DisableItem(myMenus[2],replace_);		DisableItem(myMenus[2],findNext_);		DisableItem(myMenus[2],replaceFind_);		//if (ZeroScrap()) reportMessage ("Unable to Zero scrap","");		//else if (TEToScrap()) reportMessage ("Unable to write scrap","");	}	/*else if (mode == iconFactory) {	//--- 19 apr 97 --- This is not needed as all icons 															are instantly written to scrap.		IconToScrap();	}*/	EnableItem(myMenus[2],undo_);	EnableItem(myMenus[2],cut_);	EnableItem(myMenus[2],copy_);	EnableItem(myMenus[2],paste_);	EnableItem(myMenus[2],clear_);}void updateEvent(void){	BeginUpdate(myWindow);		(*updateFun[mode])();		universalUpdate();	EndUpdate(myWindow);}void diskEvent(void){	Point where = {100,100};		if (HiWord(myEvent.message)) {		DILoad();		DIBadMount(where,myEvent.message);		DIUnload();	}}void mainEventLoop(void){	short eventHappened;		if (features.hasWaitNextEvent) 		eventHappened = WaitNextEvent(everyEvent,&myEvent,5,NULL);	else {		SystemTask();		eventHappened = GetNextEvent(everyEvent,&myEvent);	}		if (mode == draftingBoard) draftingSpecial();	else if (mode == iconFactory) iconSpecial();		//TSMEvent(&myEvent); // Text Handling for event...		if (eventHappened) {		switch (myEvent.what) {			case mouseDown: mouseEvent(); break;			case keyDown:			case autoKey: keyEvent(); break;			case activateEvt: activateEvent(); break;			case osEvt: osEvent(); break;			case updateEvt: updateEvent(); break;			case diskEvt: diskEvent(); break;			case kHighLevelEvent: if (features.hasAppleEventManager)									highLevelEvent(&myEvent); break;			case nullEvent: WEIdle(nil, myWText); break;		}	}}/**** Shutdown Routines ****/void closeProgram(void){	clearChannel();	if (mode == draftingBoard) {		if (modifyFlag) saveRobot();		WEDispose(myWText);		//TEDispose(myText);	}	else if (mode == hardwareStore)		closeHardware();	else if (mode == arena)		closeArena();	else if (mode == iconFactory)		closeIcons();	else if (mode == recordingStudio)		closeRecording();	writePrefs();	LoadScrap();			// remove drag handlers	//if ( features.hasDragAndDrop )	//	RemoveDragHandlers( );	// notify text services that we're closing down	CloseTSMAwareApplication( );	// notify SmartScroll we're closing down	//CloseSmartScrollAwareApplication( );}/**** Main ****/void main(void){	initMac();	initProgram();	while (!quitFlag) mainEventLoop();	closeProgram();}